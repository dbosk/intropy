\tableofcontents
\clearpage

\section{Inledning}

När studenterna skriver Datorprovet behöver de ha rätt på två av tre frågor på 
varje lärandemål.
Mappningen är enligt följande.

\begin{tabular}{rll}
\(n\) & Lärandemål & Frågor\\
\hline
1 & Programmerarvänliga program och tilldelningar & Frågorna 1-3\\
2 & Tillämpa styrstrukturer & Frågorna 4-6\\
3 & Utforma och presentera användarvänliga utdata & Frågorna 7-9\\
4 & Överföra data mellan fil och program & Frågorna 10-12\\
5 & Konstruera interaktiva program & Frågorna 13-15\\
6 & Använda och konstruera sammansatta datatyper och klasser & Frågorna 16-18\\
7 & Dela upp ett program & Frågorna 19-21\\
\hline
\end{tabular}
Då är poängen för varje fråga på lärandemål \(n\), \(10^{n-1}\).
Studenternas resultat ser ut enligt följande.
\begin{verbatim}
$ canvaslms submissions -c prgm24 -a Datorprov -l \
  | cut -f 3,4 | egrep "[0-3]+"
user1@kth.se	1001122
user2@kth.se	2332132
user3@kth.se	1232232
user4@kth.se	3333333
user5@kth.se	3222213
\end{verbatim}

Vi vill ha ett program, [[<<datorprov.sh>>]], som läser vilka moment som 
studenterna har bonus på och ut en sträng som motsvarar samma ordning som i 
Datorprovet.
Då kan vi bara addera dessa för att få fram vilka frågor som studenten uppnått 
godkänt på.
Bonuspoängen finns lagrad per lärandemål i Canvas:

\begin{verbatim}
$ canvaslms assignments -c prgm24 -a ^Bonus: | cut -f 3
Bonus: Programmerarvänliga program och tilldelningar
Bonus: Tillämpa styrstrukturer
Bonus: Utforma och presentera användarvänlig utdata
Bonus: Överföra data mellan fil och program
Bonus: Konstruera interaktiva program
Bonus: Använda och konstruera sammansatta datatyper
Bonus: Dela upp ett program
\end{verbatim}


\section{Översikt över programmet}

Det vi vill göra är följande.
<<datorprov.sh>>=
#!/bin/bash

<<konfigurationsvariabler>>
<<hjälpfunktioner>>

<<spara resultat från Canvas i [[${results}]]>>

all() {
  <<låt [[students]] vara en lista med alla studenter>>
  for student in ${students}; do
    <<skriv ut [[student]]ens resultat>>
    <<skriv även ut summan av [[student]]ens bonus och datorprov>>
  done
}

<<andra kommandon>>

<<kör [[all]] eller angivet kommando>>
@

Vi kan låta användaren ange ett kommando på kommandoraden.
Om man vill köra [[all]] så kör man bara [[./datorprov.sh]].
Om man vill köra ett annat kommando än [[all]], så kan man köra
[[./datorprov.sh kommando]].
<<kör [[all]] eller angivet kommando>>=
if [ $# -eq 0 ]; then
  all
else
  $@
fi
@


\section{Spara resultat från Canvas}

För att spara resultatet från Canvas i en fil, kan vi använda 
[[canvaslms]].
Frågan är: för vilken kurs?
Låt oss ta kursen som argument.
<<spara resultat från Canvas i [[${results}]]>>=
course=$1
shift
results=/tmp/results-${course}.csv
@ Genom att använda [[$1]] och [[shift]] kan vi använda resterande argument som 
kommandon till programmet.
Eftersom vi gör [[shift]] kommer koden för
[[<<kör [[all]] eller angivet kommando>>]]
att fungera som att det vi gjorde ovan in fanns.
Men nu kommer man använda programmet genom att köra
[[./datorprov.sh prgm24 kommando]].

Vi vill dock bara göra detta om filen inte redan finns.
<<spara resultat från Canvas i [[${results}]]>>=
if [ ! -f ${results} ]; then
  canvaslms submissions -c ${course} -a "(Datorprov|Bonus:)" -l \
    | cut -f 2-4 \
    > ${results}
fi
@ Filen har kolumnerna uppgift, student och poäng (i den ordningen).

För att underlätta för användaren kan vi lägga till ett kommando för att rensa 
filen med resultat.
<<andra kommandon>>=
clean() {
  rm ${results}
}
@


\section{Skapa en lista med alla studenter}

Nu när vi har alla resultat i en fil, kan vi skapa en lista med alla studenter 
genom att hämta dem från filen.
<<låt [[students]] vara en lista med alla studenter>>=
students=$(cut -f 2 ${results} | sort | uniq)
@


\section{Skriv ut [[student]]ens resultat}

Vi vill skriva ut både studentens resultat och bonuspoängen; båda på samma 
format, en på varje rad.
\begin{verbatim}
user1@kth.se Bonus 1011011
user1@kth.se Datorprov 1001122
\end{verbatim}
<<skriv ut [[student]]ens resultat>>=
<<skriv ut [[student]]ens bonuspoäng>>
<<skriv ut [[student]]ens datorprovspoäng>>
@

\subsection{Studentens bonuspoäng}

Låt oss fokusera på att skriva ut studentens bonuspoäng.
\begin{verbatim}
user1@kth.se Bonus 1011011
\end{verbatim}
<<skriv ut [[student]]ens bonuspoäng>>=
bonus=$(<<sätt ihop bonussträngen för [[student]]>>)
echo -e "${student}\tBonus\t${bonus}"
@

Det vi har som indata är följande.
\begin{verbatim}
Bonus: Programmerarvänliga program och tilldelningar	user1@kth.se	1
Bonus: Tillämpa styrstrukturer	user1@kth.se	1
Bonus: Utforma och presentera användarvänlig utdata	user1@kth.se	
Bonus: Överföra data mellan fil och program	user1@kth.se	1
Bonus: Konstruera interaktiva program	user1@kth.se	1
Bonus: Använda och konstruera sammansatta datatyper	user1@kth.se	
Bonus: Dela upp ett program	user1@kth.se	1
\end{verbatim}

För att skriva ut studentens bonuspoäng börjar vi med att skriva ut 
bonuspoängen (0 eller 1) för varje område, i rätt ordning.
För att skriva ut bonuspoängen för ett område, kan vi använda följande 
hjälpfunktion.
Den läser ut bonuspoängen för en student och ett område från filen.
Om det inte finns någon bonuspoäng, då är kolumnen tom, men vi ska då skriva ut 
0.
<<hjälpfunktioner>>=
bonus() {
  local file=$1
  local student=$2
  local area=$3
  local points=$(grep "${student}" ${file} | grep "${area}" | cut -f 3)
  if [ -z "${points}" ]; then
    echo 0
  else
    echo ${points}
  fi
}
@

Med rätt ordning menar vi att den första (Programmeringsvänliga program och 
tilldelningar) ska vara den sista siffran.
Därefter kan vi slå ihop raderna till en rad på rätt format med [[tr]].
<<sätt ihop bonussträngen för [[student]]>>=
(bonus ${results} $student "Bonus: Dela upp ett program"; \
 bonus ${results} $student \
  "Bonus: Använda och konstruera sammansatta datatyper"; \
 bonus ${results} $student "Bonus: Konstruera interaktiva program"; \
 bonus ${results} $student "Bonus: Överföra data mellan fil och program"; \
 bonus ${results} $student \
  "Bonus: Utforma och presentera användarvänlig utdata"; \
 bonus ${results} $student "Bonus: Tillämpa styrstrukturer"; \
 bonus ${results} $student \
  "Bonus: Programmerarvänliga program och tilldelningar") \
| tr -d '\n'
@

\subsection{Studentens datorprovspoäng}

Vi vill nu skriva ut studentens datorprovspoäng på samma sätt som vi skrev ut 
bonuspoängen.
\begin{verbatim}
user1@kth.se Datorprov 1001122
\end{verbatim}
Detta är enkelt då detta redan finns i filen [[${results}]].
Vi vill dock byta ordning på kolumn 1 och 2 (student och Datorprov).
<<skriv ut [[student]]ens datorprovspoäng>>=
points=$(grep "${student}" ${results} | grep Datorprov | cut -f 3 | round)
echo -e "${student}\tDatorprov\t${points}"
@

Då Canvas ibland slänger in en massa decimaler, exempelvis att poängen slutar 
med \(2.9999999\), då måste vi avrunda det till 3.
Detta kan vi göra med följande trick\footnote{%
  \texttt{https://stackoverflow.com/questions/68878409/rounding-floats-to-integer-under-bash}
}.
Men vi vill bara göra något om det finns poäng.
Om studenten inte har skrivit provet så är poängen en tom sträng, då hoppar vi 
vidare utan att göra något.
<<hjälpfunktioner>>=
round() {
  local points=$(cat)
  if [ -n "${points}" ]; then
    echo "(${points} + 0.5) / 1" | bc
  fi
}
@


\section{Skriv ut summan av bonus och datorprov}

Vi vill nu gå från
\begin{verbatim}
user1@kth.se Bonus 1011011
user1@kth.se Datorprov 1001122
\end{verbatim}
till
\begin{verbatim}
user1@kth.se Bonus 1011011
user1@kth.se Datorprov 1001122
user1@kth.se Datorprov med bonus 2012133
\end{verbatim}

Vi har redan skrivit ut de första två raderna.
Vi har även värdena [[bonus]] och [[points]] (för datorprovet).
Om de inte skrivit datorprovet kommer [[points]] vara en tom sträng, då hoppar 
vi vidare.
<<skriv även ut summan av [[student]]ens bonus och datorprov>>=
if [ -z "${points}" ]; then
  sum=${bonus}
else
  sum=$(echo ${bonus} + ${points} | bc)
fi
echo -e "${student}\tDatorprov med bonus\t${sum}"
@


\section{Andra kommandon}

Vi vill nu lägga till lite fler kommandon.
Detta görs i form av att lägga till funktioner i [[<<andra kommandon>>]].

\subsection{Alla godkända}

Vi vill nu lägga till ett kommando för att lista alla godkända.
Då kan vi helt enkelt kolla på alla studenter som har minst 2:or rakt igenom 
efter att vi lagt till bonus.
<<andra kommandon>>=
P() {
  all \
  | grep "med bonus" \
  | egrep "[2-4]{7}"
}
@

\subsection{Godkända utan bonus}

Vi vill även se vilka som blev godkända utan att behöva sin bonuspoäng.
<<andra kommandon>>=
PutanBonus() {
  all \
  | grep "Datorprov" | grep -v "med bonus" \
  | egrep "[2-4]{7}"
}
@

\subsection{Lista kompletteringar}

Vi vill nu lägga till ett kommando för att lista alla kompletteringar.
Vi vill då filtrera bort alla godkända.
Därefter vill vi hitta alla som har max en 1:a och resten lägst 2:or.
<<andra kommandon>>=
Fx() {
  all \
  | grep "med bonus" \
  | egrep -v "[2-4]{7}" \
  | egrep "[0-4]{7}" \
  | egrep "\s[2-4]*[01][2-4]*($|\.)"
}
@

\subsection{Lista de som inte skrev}

Vi vill nu lägga till ett kommando för att lista alla som inte skrev.
Vi vill då bara lista dem som inte har något resultat på datorprovet.
<<andra kommandon>>=
nothing() {
  grep "Datorprov" ${results} | egrep "\s$" | cut -f 2
}
@

\subsection{Lista underkända}

Vi vill nu lägga till ett kommando för att lista alla underkända.
Vi vill då bara lista dem som gjort ett försök att skriva.
<<andra kommandon>>=
F() {
  all \
  | <<filtrera bort övriga>> \
  | grep "med bonus"
}
@

Vi vill också ha ett kommando för alla underkända, vare sig de har F eller Fx.
Detta är användbart i de fall vi inte tillämpar komplettering (Fx), utan vill 
sätta F på alla som skrev som inte fick P.
<<andra kommandon>>=
ickeP() {
  all \
  | grep "med bonus" \
  | <<filtrera bort alla med P och som inte skrev>>
}
@

För att filtrera bort studenter kan vi använda funktionerna ovan, plocka ut 
studenternas identifierare och använda [[grep -v -f]] med 
[[bash]]-funktionaliteten [[<(...)]], som skapar en temporär fil.
<<filtrera bort övriga>>=
grep -v -f <(P | cut -f 1; Fx | cut -f 1; nothing)
<<filtrera bort alla med P och som inte skrev>>=
grep -v -f <(P | cut -f 1; nothing)
@


\section{Rapportera resultaten till Canvas}

Vi vill nu rapportera resultaten till Canvas.
Det upplägg vi har är att studenterna behöver skriva om provet om de inte har 
klarat det.
Vi har två upplägg:
\begin{itemize}
\item På prgi behöver de skriva om provet i sin helhet om de inte klarat det.
\item På prgm behöver de bara skriva om de lärandemål de inte klarat.
\end{itemize}

Det vi vill rapportera är följande, för varje student vill vi rapportera:
\begin{itemize}
\item betyget, P eller F;
\item vilka lärandemål (och frågor) som de blev underkända på.
\end{itemize}
Sedan vill vi även lägga till en kommentar för studenterna på prgm att de bara 
behöver skriva om de lärandemål de blev underkända på.

Vi vill ha ett kommando för att rapportera resultaten.
<<andra kommandon>>=
rapportera() {
  <<avgör om vi ska använda bonus>>
  <<för varje [[student]] som gjort något>>
  do
    <<låt [[bonus]] vara [[student]]ens bonuspoäng>>
    <<låt [[points]] vara [[student]]ens datorprovspoäng>>
    <<låt [[points_with_bonus]] vara summan av [[bonus]] och [[points]]>>
    grade=$(compute_grade ${points_with_bonus})
    feedback=$(lo_feedback ${points} ${bonus})
    echo canvaslms grade -c ${course} -a "Betyg datorprov" \
      -u ${student} \
      -g ${grade} \
      -m "${feedback}"
  done
  rm ${results}
}
@


\subsection{Få ut data för studenternas resultat}

Värdena [[bonus]], [[points]] och [[points_with_bonus]] finns redan i 
utmatningen från [[all]], vi behöver bara plocka ut dem på samma sätt som vi 
plockar ut studenterna.
Och de studenter vi är intresserade av är de som fick P eller icke-P (inte de 
som inte skrev).
Eftersom det tar lite tid att köra [[all]] varje gång, vill vi spara resultatet 
i en temporär fil och använda den istället.
<<för varje [[student]] som gjort något>>=
local all_cache=$(mktemp)
all > ${all_cache}
for student in $(<<filtrera ut alla relevanta studenter>>)
<<låt [[bonus]] vara [[student]]ens bonuspoäng>>=
local bonus=$(grep "${student}" ${all_cache} | grep Bonus | cut -f 3)
<<låt [[points]] vara [[student]]ens datorprovspoäng>>=
local points=$(grep "${student}" ${all_cache} \
  | grep -P "Datorprov(?! med bonus)" | cut -f 3)
<<låt [[points_with_bonus]] vara summan av [[bonus]] och [[points]]>>=
local points_with_bonus=$(grep "${student}" ${all_cache} \
  | grep "med bonus" | cut -f 3)
@

\subsection{Filtrera ut relevanta studenter}

De studenter som är relevanta är alla som fått P eller icke-P---men som inte 
redan har ett P rapporterat i `Betyg datorprov`.
Notera att vi vill bara ha deras e-postadresser (första kolumnen från [[P]] och 
[[ickeP]]).
<<filtrera ut alla relevanta studenter>>=
(P; ickeP) \
| cut -f 1 | sort | uniq \
| <<filtrera ut alla som redan har P som betyg>>
<<filtrera ut alla som redan har P som betyg>>=
grep -v -f <(canvaslms submissions -c ${course} -a "Betyg datorprov" -l \
             | grep -E "\sP\s" | cut -f 3)
@


\subsection{Beräkna betyg}

Vi vill nu skriva en funktion som beräknar betyget på samma sätt som ovan.
Om studenten fått minst 2:or rakt igenom, då har hen fått P, annars F.
Men om studenten inte har någon poäng alls (dvs. hen inte skrev, och poängen är 
en tom sträng), då ska hen inte få något betyg (det ska vara en tom sträng).
<<hjälpfunktioner>>=
compute_grade() {
  local points=$1
  if [ $(echo ${points} | egrep -c "[2-4]{7}") -eq 1 ]; then
    echo P
  elif [ -z "${points}" ]; then
    return
  else
    echo F
  fi
}
@


\subsection{Avgöra om vi ska använda bonus}

Vi vill avgöra från kursnamnet i [[course]] om vi ska använda bonus eller inte.
De kurser som ska använda bonus har kurskod DD1310 eller inleds med prgm.
<<avgör om vi ska använda bonus>>=
if [ $(echo ${course} | egrep -c "DD1310|prgm") -eq 1 ]; then
  BONUSPOINTS=1
else
  BONUSPOINTS=0
fi
@


\subsection{Lista lärandemål och frågor}

Vi vill nu skriva en hjälpfunktion som tar en students poäng och returnerar 
(skriver ut till stdout) vilka lärandemål och motsvarande frågor de behöver 
jobba mer med.
<<hjälpfunktioner>>=
lo_feedback() {
  local points=$1
  local bonus=$2
  local count_full_score=0
  for lo_num in $(seq 1 7); do
    local lo_points=$((points % 10))
    local bonus_points=$((bonus % 10))
    if [ ${lo_points} -ge 3 ]; then
      <<öka på [[count_full_score]]>>
    else
      <<skriv ut namn och frågor för lärandemål [[lo_num]]>>
      <<skriv ut återkoppling för [[lo_points]]>>
      echo # för blankrad mellan lärandemål
    fi
    points=$((points / 10))
    bonus=$((bonus / 10))
  done
  <<skriv ut hur många lärandemål studenten fick full pott på>>
}
@

Man kan få maximalt tre poäng utan bonus.
Det krävs två poäng för att klara ett lärandemål.
Om studenten har fått tre av tre behöver vi inte skriva ut något, då räcker det 
med att vi ökar på antalet.
<<öka på [[count_full_score]]>>=
count_full_score=$((count_full_score + 1))
@ Om studenten fått full pott på åtminstone ett lärandemål, då skriver vi det.
Om de fått full pott på alla lärandemål, då skriver vi något extra positivt.
<<skriv ut hur många lärandemål studenten fick full pott på>>=
if [ ${count_full_score} -eq 7 ]; then
  echo "Bra jobbat, du fick full pott på alla lärandemål!"
elif [ ${count_full_score} -gt 0 ]; then
  echo "Sedan fick du full pott på övriga lärandemål (${count_full_score})." \
       "Bra jobbat!"
fi
@

Vi vill ha en funktion som översätter lärandemålets nummer till dess namn.
<<hjälpfunktioner>>=
lo_name() {
  case $1 in
    1) echo -n "Programmerarvänliga program och tilldelningar";;
    2) echo -n "Tillämpa styrstrukturer";;
    3) echo -n "Utforma och presentera användarvänlig utdata";;
    4) echo -n "Överföra data mellan fil och program";;
    5) echo -n "Konstruera interaktiva program";;
    6) echo -n "Använda och konstruera sammansatta datatyper";;
    7) echo -n "Dela upp ett program";;
  esac
}
@

Detta ger oss följande.
<<skriv ut namn och frågor för lärandemål [[lo_num]]>>=
echo -n "(${lo_num}) $(lo_name ${lo_num}) "
local first_question=$(( (lo_num - 1) * 3))
local last_questions=$((lo_num * 3))
echo -n "(frågorna ${first_question}-${last_questions}): "
@

Vi vill även ha en funktion som skriver ut återkopplingen för en viss poäng.
Om de fick två poäng vill vi säga att de uppnådde godkänd nivå, men att det 
ändå finns utrymme för förbättring.
Om de fick en poäng vill vi säga att de inte uppnådde godkänd nivå.
Men vi vill också ha en version för när vi använder bonuspoäng.
Vi kontrollerar detta med en miljövariabel.
<<hjälpfunktioner>>=
points_feedback() {
  local points=$1
  local bonus=$2
  case ${points} in
    2) echo "Dina svar uppnådde godkänd nivå," \
            "men det finns utrymme för förbättring.";;
    1|0)
       echo -n "Dina svar uppnådde inte godkänd nivå," \
               "du behöver läsa på detta område. "
       if [ "${bonus}" -eq 1 -a ${points} -eq 1 ]; then
         echo "Men du fick godkänt tack vare bonuspoängen."
       elif [ "${bonus}" -eq 0 -a "${BONUSPOINTS}" -eq 1 ]; then
         echo "Tyvärr har du inte bonuspoäng att falla tillbaka på här."
       else
         echo # för att bryta raden
       fi;;
  esac
}
<<konfigurationsvariabler>>=
BONUSPOINTS=1
@

Det ger oss följande.
<<skriv ut återkoppling för [[lo_points]]>>=
points_feedback ${lo_points} ${bonus_points}
@
