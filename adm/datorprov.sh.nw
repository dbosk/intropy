\tableofcontents
\clearpage

\section{Inledning}

När studenterna skriver Datorprovet behöver de ha rätt på två av tre frågor på 
varje lärandemål.
Mappningen är enligt följande.

\begin{tabular}{rll}
\(n\) & Lärandemål & Frågor\\
\hline
1 & Programmerarvänliga program och tilldelningar & Frågorna 1-3\\
2 & Tillämpa styrstrukturer & Frågorna 4-6\\
3 & Utforma och presentera användarvänliga utdata & Frågorna 7-9\\
4 & Överföra data mellan fil och program & Frågorna 10-12\\
5 & Konstruera interaktiva program & Frågorna 13-15\\
6 & Använda och konstruera sammansatta datatyper och klasser & Frågorna 16-18\\
7 & Dela upp ett program & Frågorna 19-21\\
\hline
\end{tabular}
Då är poängen för varje fråga på lärandemål \(n\), \(10^{n-1}\).
Studenternas resultat ser ut enligt följande.
\begin{verbatim}
$ canvaslms submissions -c prgm24 -a Datorprov -l \
  | cut -f 3,4 | egrep "[0-3]+"
user1@kth.se	1001122
user2@kth.se	2332132
user3@kth.se	1232232
user4@kth.se	3333333
user5@kth.se	3222213
\end{verbatim}

Vi vill ha ett program, [[<<datorprov.sh>>]], som läser vilka moment som 
studenterna har bonus på och ut en sträng som motsvarar samma ordning som i 
Datorprovet.
Då kan vi bara addera dessa för att få fram vilka frågor som studenten uppnått 
godkänt på.
Bonuspoängen finns lagrad per lärandemål i Canvas:

\begin{verbatim}
$ canvaslms assignments -c prgm24 -a ^Bonus: | cut -f 3
Bonus: Programmerarvänliga program och tilldelningar
Bonus: Tillämpa styrstrukturer
Bonus: Utforma och presentera användarvänlig utdata
Bonus: Överföra data mellan fil och program
Bonus: Konstruera interaktiva program
Bonus: Använda och konstruera sammansatta datatyper
Bonus: Dela upp ett program
\end{verbatim}


\section{Översikt över programmet}

Det vi vill göra är följande.
<<datorprov.sh>>=
#!/bin/bash

<<konfigurationsvariabler>>
<<hjälpfunktioner>>

<<spara resultat från Canvas i [[${results}]]>>

all() {
  <<låt [[students]] vara en lista med alla studenter>>
  for student in ${students}; do
    <<skriv ut [[student]]ens resultat>>
    <<skriv även ut summan av [[student]]ens bonus och datorprov>>
  done
}

<<andra kommandon>>

<<kör [[all]] eller angivet kommando>>
@

Vi kan låta användaren ange ett kommando på kommandoraden.
Om man vill köra [[all]] så kör man bara [[./datorprov.sh]].
Om man vill köra ett annat kommando än [[all]], så kan man köra
[[./datorprov.sh kommando]].
<<kör [[all]] eller angivet kommando>>=
if [ $# -eq 0 ]; then
  all
else
  $@
fi
@


\section{Spara resultat från Canvas}

För att spara resultatet från Canvas i en fil, kan vi använda 
[[canvaslms]].
Frågan är: för vilken kurs?
Låt oss ta kursen som argument.
<<spara resultat från Canvas i [[${results}]]>>=
course=$1
shift
results=/tmp/results-${course}.csv
@ Genom att använda [[$1]] och [[shift]] kan vi använda resterande argument som 
kommandon till programmet.
Eftersom vi gör [[shift]] kommer koden för
[[<<kör [[all]] eller angivet kommando>>]]
att fungera som att det vi gjorde ovan in fanns.
Men nu kommer man använda programmet genom att köra
[[./datorprov.sh prgm24 kommando]].

Vi vill dock bara göra detta om filen inte redan finns.
<<spara resultat från Canvas i [[${results}]]>>=
if [ ! -f ${results} ]; then
  canvaslms submissions -c ${course} -a "(Datorprov|Bonus:)" -l \
    | cut -f 2-4 \
    > ${results}
fi
@ Filen har kolumnerna uppgift, student och poäng (i den ordningen).

För att underlätta för användaren kan vi lägga till ett kommando för att rensa 
filen med resultat.
<<andra kommandon>>=
clean() {
  rm ${results}
}
@


\section{Skapa en lista med alla studenter}

Nu när vi har alla resultat i en fil, kan vi skapa en lista med alla studenter 
genom att hämta dem från filen.
<<låt [[students]] vara en lista med alla studenter>>=
students=$(cut -f 2 ${results} | sort | uniq)
@


\section{Skriv ut [[student]]ens resultat}

Vi vill skriva ut både studentens resultat och bonuspoängen; båda på samma 
format, en på varje rad.
\begin{verbatim}
user1@kth.se Bonus 1011011
user1@kth.se Datorprov 1001122
\end{verbatim}
<<skriv ut [[student]]ens resultat>>=
<<skriv ut [[student]]ens bonuspoäng>>
<<skriv ut [[student]]ens datorprovspoäng>>
@

\subsection{Studentens bonuspoäng}

Låt oss fokusera på att skriva ut studentens bonuspoäng.
\begin{verbatim}
user1@kth.se Bonus 1011011
\end{verbatim}
<<skriv ut [[student]]ens bonuspoäng>>=
bonus=$(<<sätt ihop bonussträngen för [[student]]>>)
echo -e "${student}\tBonus\t${bonus}"
@

Det vi har som indata är följande.
\begin{verbatim}
Bonus: Programmerarvänliga program och tilldelningar	user1@kth.se	1
Bonus: Tillämpa styrstrukturer	user1@kth.se	1
Bonus: Utforma och presentera användarvänlig utdata	user1@kth.se	
Bonus: Överföra data mellan fil och program	user1@kth.se	1
Bonus: Konstruera interaktiva program	user1@kth.se	1
Bonus: Använda och konstruera sammansatta datatyper	user1@kth.se	
Bonus: Dela upp ett program	user1@kth.se	1
\end{verbatim}

För att skriva ut studentens bonuspoäng börjar vi med att skriva ut 
bonuspoängen (0 eller 1) för varje område, i rätt ordning.
För att skriva ut bonuspoängen för ett område, kan vi använda följande 
hjälpfunktion.
Den läser ut bonuspoängen för en student och ett område från filen.
Om det inte finns någon bonuspoäng, då är kolumnen tom, men vi ska då skriva ut 
0.
<<hjälpfunktioner>>=
bonus() {
  file=$1
  student=$2
  area=$3
  points=$(grep "${student}" ${file} | grep "${area}" | cut -f 3)
  if [ -z "${points}" ]; then
    echo 0
  else
    echo ${points}
  fi
}
@

Med rätt ordning menar vi att den första (Programmeringsvänliga program och 
tilldelningar) ska vara den sista siffran.
Därefter kan vi slå ihop raderna till en rad på rätt format med [[tr]].
<<sätt ihop bonussträngen för [[student]]>>=
(bonus ${results} $student "Bonus: Dela upp ett program"; \
 bonus ${results} $student \
  "Bonus: Använda och konstruera sammansatta datatyper"; \
 bonus ${results} $student "Bonus: Konstruera interaktiva program"; \
 bonus ${results} $student "Bonus: Överföra data mellan fil och program"; \
 bonus ${results} $student \
  "Bonus: Utforma och presentera användarvänlig utdata"; \
 bonus ${results} $student "Bonus: Tillämpa styrstrukturer"; \
 bonus ${results} $student \
  "Bonus: Programmerarvänliga program och tilldelningar") \
| tr -d '\n'
@

\subsection{Studentens datorprovspoäng}

Vi vill nu skriva ut studentens datorprovspoäng på samma sätt som vi skrev ut 
bonuspoängen.
\begin{verbatim}
user1@kth.se Datorprov 1001122
\end{verbatim}
Detta är enkelt då detta redan finns i filen [[${results}]].
Vi vill dock byta ordning på kolumn 1 och 2 (student och Datorprov).
<<skriv ut [[student]]ens datorprovspoäng>>=
points=$(grep "${student}" ${results} | grep Datorprov | cut -f 3)
echo -e "${student}\tDatorprov\t${points}"
@


\section{Skriv ut summan av bonus och datorprov}

Vi vill nu gå från
\begin{verbatim}
user1@kth.se Bonus 1011011
user1@kth.se Datorprov 1001122
\end{verbatim}
till
\begin{verbatim}
user1@kth.se Bonus 1011011
user1@kth.se Datorprov 1001122
user1@kth.se Datorprov med bonus 2012133
\end{verbatim}

Vi har redan skrivit ut de första två raderna.
Vi har även värdena [[bonus]] och [[points]] (för datorprovet).
Om de inte skrivit datorprovet kommer [[points]] vara en tom sträng, då hoppar 
vi vidare.
<<skriv även ut summan av [[student]]ens bonus och datorprov>>=
if [ -z "${points}" ]; then
  sum=${bonus}
else
  sum=$(echo ${bonus} + ${points} | bc)
fi
echo -e "${student}\tDatorprov med bonus\t${sum}"
@


\section{Andra kommandon}

Vi vill nu lägga till lite fler kommandon.
Detta görs i form av att lägga till funktioner i [[<<andra kommandon>>]].

\subsection{Alla godkända}

Vi vill nu lägga till ett kommando för att lista alla godkända.
Då kan vi helt enkelt kolla på alla studenter som har minst 2:or rakt igenom 
efter att vi lagt till bonus.
<<andra kommandon>>=
P() {
  all \
  | grep "med bonus" \
  | egrep "[2-4]{7}"
}
@

\subsection{Godkända utan bonus}

Vi vill även se vilka som blev godkända utan att behöva sin bonuspoäng.
<<andra kommandon>>=
PutanBonus() {
  all \
  | grep "Datorprov" | grep -v "med bonus" \
  | egrep "[2-4]{7}"
}
@

\subsection{Lista kompletteringar}

Vi vill nu lägga till ett kommando för att lista alla kompletteringar.
Vi vill då filtrera bort alla godkända.
Därefter vill vi hitta alla som har max en 1:a och resten lägst 2:or.
<<andra kommandon>>=
Fx() {
  all \
  | grep "med bonus" \
  | egrep -v "[2-4]{7}" \
  | egrep "[0-4]{7}" \
  | egrep "\s[2-4]*[01][2-4]*($|\.)"
}
@

\subsection{Lista de som inte skrev}

Vi vill nu lägga till ett kommando för att lista alla som inte skrev.
Vi vill då bara lista dem som inte har något resultat på datorprovet.
<<andra kommandon>>=
nothing() {
  grep "Datorprov" ${results} | egrep "\s$" | cut -f 2
}
@

\subsection{Lista underkända}

Vi vill nu lägga till ett kommando för att lista alla underkända.
Vi vill då bara lista dem som gjort ett försök att skriva.
<<andra kommandon>>=
F() {
  all \
  | <<filtrera bort övriga>> \
  | grep "med bonus"
}
@

Vi vill också ha ett kommando för alla underkända, vare sig de har F eller Fx.
Detta är användbart i de fall vi inte tillämpar komplettering (Fx), utan vill 
sätta F på alla som skrev som inte fick P.
<<andra kommandon>>=
ickeP() {
  all \
  | grep "med bonus" \
  | <<filtrera bort alla med P och som inte skrev>>
}
@

För att filtrera bort studenter kan vi använda funktionerna ovan, plocka ut 
studenternas identifierare och använda [[grep -v -f]] med 
[[bash]]-funktionaliteten [[<(...)]], som skapar en temporär fil.
<<filtrera bort övriga>>=
grep -v -f <(P | cut -f 1; Fx | cut -f 1; nothing)
<<filtrera bort alla med P och som inte skrev>>=
grep -v -f <(P | cut -f 1; nothing)
@


\section{Rapportera resultaten till Canvas}

Vi vill nu rapportera resultaten till Canvas.
Det upplägg vi har är att studenterna behöver skriva om provet om de inte har 
klarat det.
Vi har två upplägg:
\begin{itemize}
\item På prgi behöver de skriva om provet i sin helhet om de inte klarat det.
\item På prgm behöver de bara skriva om de lärandemål de inte klarat.
\end{itemize}

Det vi vill rapportera är följande, för varje student vill vi rapportera:
\begin{itemize}
\item betyget, P eller F;
\item vilka lärandemål (och frågor) som de blev underkända på.
\end{itemize}
Sedan vill vi även lägga till en kommentar för studenterna på prgm att de bara 
behöver skriva om de lärandemål de blev underkända på.

\subsection{Lista lärandemål och frågor}

Vi vill nu skriva en hjälpfunktion som tar en students poäng och returnerar 
(skriver ut till stdout) vilka lärandemål och motsvarande frågor de behöver 
jobba mer med.
<<hjälpfunktioner>>=
lo_återkoppling() {
  points=$1
  bonus=$2
  antal_full_pott=0
  for lo_num in $(seq 1 7); do
    lo_points=$((points % 10))
    bonus_points=$((bonus % 10))
    if [ ${lo_points} -eq 3 ]; then
      <<öka på [[antal_full_pott]]>>=
    else
      <<skriv ut namn och frågor för lärandemål [[lo_num]]>>
      <<skriv ut återkoppling för [[lo_points]]>>
      echo # för blankrad mellan lärandemål
    fi
    points=$((points / 10))
    bonus=$((bonus / 10))
  done
  <<skriv ut hur många lärandemål studenten fick full pott på>>
}
@

Man kan få maximalt tre poäng utan bonus.
Det krävs två poäng för att klara ett lärandemål.
Om studenten har fått tre av tre behöver vi inte skriva ut något, då räcker det 
med att vi ökar på antalet.
<<öka på [[antal_full_pott]]>>=
antal_full_pott=$((antal_full_pott + 1))
@ Om studenten fått full pott på åtminstone ett lärandemål, då skriver vi det.
<<skriv ut hur många lärandemål studenten fick full pott på>>=
if [ ${antal_full_pott} -gt 0 ]; then
  echo
  echo "Sedan fick du full pott på övriga lärandemål (${antal_full_pott})."
fi
@

Vi vill ha en funktion som översätter lärandemålets nummer till dess namn.
<<hjälpfunktioner>>=
lo_name() {
  case $1 in
    1) echo -n "Programmerarvänliga program och tilldelningar";;
    2) echo -n "Tillämpa styrstrukturer";;
    3) echo -n "Utforma och presentera användarvänlig utdata";;
    4) echo -n "Överföra data mellan fil och program";;
    5) echo -n "Konstruera interaktiva program";;
    6) echo -n "Använda och konstruera sammansatta datatyper";;
    7) echo -n "Dela upp ett program";;
  esac
}
@

Detta ger oss följande.
<<skriv ut namn och frågor för lärandemål [[lo_num]]>>=
echo -n "${lo_num} $(lo_name ${lo_num}) "
första_frågan=$(( (lo_num - 1) * 3))
sista_frågan=$((lo_num * 3))
echo -n "(frågorna ${första_frågan}-${sista_frågan}): "
@

Vi vill även ha en funktion som skriver ut återkopplingen för en viss poäng.
Om de fick två poäng vill vi säga att de uppnådde godkänd nivå, men att det 
ändå finns utrymme för förbättring.
Om de fick en poäng vill vi säga att de inte uppnådde godkänd nivå.
Men vi vill också ha en version för när vi använder bonuspoäng.
Vi kontrollerar detta med en miljövariabel.
<<hjälpfunktioner>>=
poäng_återkoppling() {
  poäng=$1
  bonus=$2
  case ${poäng} in
    2) echo "Du uppnådde godkänd nivå," \
            "men det finns ett litet utrymme för förbättring.";;
    1|0)
       echo -n "Dina svar uppnådde inte godkänd nivå," \
               "du behöver läsa på detta område. "
       if [ "${bonus}" -eq 1 -a ${poäng} -eq 1 ]; then
         echo "Men du fick godkänt tack vare bonuspoängen."
       else if [ "${bonus}" -eq 0 -a "BONUSPOÄNG" -eq 1 ]; then
         echo "Tyvärr har du inte bonuspoäng att falla tillbaka på här."
       fi;;
  esac
}
<<konfigurationsvariabler>>=
BONUSPOÄNG=1
@

