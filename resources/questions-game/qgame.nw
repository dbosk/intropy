\documentclass[a4paper]{article}
\usepackage{noweb}
% Needed to relax penalty for breaking code chunks across pages, otherwise 
% there might be a lot of space following a code chunk.
\def\nwendcode{\endtrivlist \endgroup}
\let\nwdocspar=\smallbreak

\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage{authblk}

\input{preamble.tex}

\title{%
  Ett frågespel
}
\author{%
  Daniel Bosk
}

\begin{document}
\maketitle
\clearpage

\tableofcontents
\clearpage

@
\section{Inledning}

Vi vill skriva ett frågespel.
Frågespelet ska ha kluriga frågor som användaren ska svara på.
Frågorna ska kunna ha olika följdfrågor beroende på användarens svar 
(exempelvis ge ledningar) och ibland flera möjliga svar.


\section{Kodens struktur}

Detta program har den vanliga strukturen för ett litet pythonprogram där all 
kod finns i en fil:
<<qgame.py>>=
"""Ett frågespel"""

import base64
import random
import sys

<<hjälpfunktioner>>

def main():
  """Huvudprogrammet"""
  <<huvudprogrammets innehåll>>

if __name__ == "__main__":
  main()
@


\section{Huvudprogrammets innehåll}

Huvudprogrammet ska köra själva spelet.
Designen är som följer.

Huvudprogrammet kör igenom en lista med frågor ([[for]]-satsen).
Det ställer frågan och så länge detta resulterar i en ny följdfråga ställer vi 
även den frågan ([[while]]-satsen).
Om det inte blir någon följdfråga avslutas [[while]]-satsen.
Därefter fortsätter vi med nästa fråga tills att alla frågor är slut.

När alla frågar har gåtts igenom, vilket betyder att alla är korrekta, så kan 
vi skriva ut presenten.
<<huvudprogrammets innehåll>>=
<<skapa lista med frågor, questions>>

for question in questions:
  while follow_up_question := ask_question(question):
    question = follow_up_question

<<skriv ut presenten>>
@


\section{Frågornas format}

Det mest intressanta i huvudprogrammet är frågornas format.
Formatet bestämmer nämligen hur funktionen [[ask_question]] ska utformas.
Vi ser ovan att [[ask_question]] tar en fråga som argument och returnerar 
eventuell följdfråga.
Om det inte blir någon följdfråga returneras [[None]].
Om svaret är fel kan vi returnera samma fråga igen.
Om något med svaret är fel, kastas ett särfall av typen [[ValueError]].
Detta skrivs ut, sedan ställs samma fråga igen.
<<hjälpfunktioner>>=
def ask_question(question):
  """
  Takes a question object as argument, asks the question and returns any 
  follow-up question. If there is no follow-up question, None is returned.
  """
  while True:
    try:
      return question()
    except ValueError as err:
      print(err)
@

Detta betyder att frågorna måste vara \enquote{callable}.
Detta betyder att de kan antingen vara objekt som är \enquote{callable} eller 
faktiska funktioner.
Detta betyder dock att frågorna själva får hantera in- och utmatningen.


\section{Frågorna}

Nu när vi skapar frågorna kommer vi att definiera en funktion för frågan och 
lägga till den i listan.
<<skapa lista med frågor, questions>>=
questions = []
<<lägg till frågor i questions>>
@

\subsection{Den 8 november}

Vi börjar med en fråga om 8 november.
Det är två saker vi är ute efter: Tomas födelsedag och Läromedlets dag.
Om de får den ena rätt vill vi att de ska hitta den andra.

Det vi kan göra för att åstadkomma detta är att att kolla på svaret.
Om användaren svarar Tomas så vill vi ha en följdfråga om Läromedlets dag och 
vice versa.
För att åstadkomma följdfrågan returnerar vi funktionen som behandlar den 
frågan.
Vi har en följdfråga om Läromedlets dag, detta är funktionen [[textbook_day]].
Den andra följdfrågan är om Tomas, detta är funktionen [[tomas_birthday]].

För att kunna hantera väldigt varierande svar så kollar vi bara efter de mest 
kritiska delarna av ett svar.
Exempelvis kollar vi om svaret från användaren innehåller \enquote{tomas} (vår 
användning av [[.casefold()]] gör om svaret till gemener).
<<hjälpfunktioner>>=
def eighth_nov():
  """
  En fråga om 8 november.
  """
  answer = input("Vad händer den 8 november? ").casefold()
  if "tomas" in answer:
    print("Precis!")
    return textbook_day
  elif "läromed" in answer:
    print("Precis!")
    return tomas_birthday
  else:
    print("Nej, det var fel!")
    return eighth_nov
@

Nu kan vi lägga till funktionen till frågorna.
<<lägg till frågor i questions>>=
questions.append(eighth_nov)
@

Sedan vill vi skapa och lägga till de specifika följdfrågorna.
Det är samma konstruktion som tidigare.
Om användaren svarar fel kan vi returnera funktionen själv för att repetera 
samma fråga igen.
<<hjälpfunktioner>>=
def textbook_day():
  """
  Följdfråga om Läromedlets dag
  """
  answer = input("Det är något annat med den 8 november också, "
                 "vad? ").casefold()
  if "läromed" in answer:
    print("Precis!")
  elif "tomas" in answer:
    print("Det har du redan sagt.")
    return textbook_day
  else:
    print("Nja, inte det vi är ute efter. Kolla\n"
          "https://sv.wikipedia.org/wiki/8_november")
    return textbook_day

def tomas_birthday():
  """
  Följdfråga om Tomas födelsedag
  """
  answer = input("Det är något annat med den 8 november också, "
                 "vad? ").casefold()
  if "tomas" in answer:
    print("Precis!")
  elif "läromed" in answer:
    print("Det har du redan sagt.")
    return tomas_birthday
  else:
    print("Nja, inte det vi är ute efter.")
    return tomas_birthday
@

\subsection{Den 13 december}

Nu tar vi en fråga om 13 december.
Det är två saker vi är ute efter: Noas födelsedag och Lucia.
Om de får den ena rätt vill vi att de ska hitta den andra.
<<hjälpfunktioner>>=
def thirteenth_dec():
  """
  En fråga om 13 december.
  """
  answer = input("Vad händer den 13 december? ").casefold()
  if "noa" in answer:
    print("Precis!")
    return lucia
  elif "lucia" in answer:
    print("Precis!")
    return noa_birthday
  else:
    print("Nej, det var fel!")
    return thirteenth_dec
@

Nu kan vi lägga till funktionen till frågorna.
<<lägg till frågor i questions>>=
questions.append(thirteenth_dec)
@

Sedan vill vi skapa och lägga till de specifika följdfrågorna.
<<hjälpfunktioner>>=
def lucia():
  """
  Följdfråga om Lucia
  """
  answer = input("Det är något annat med den 13 december också, "
                 "vad? ").casefold()
  if "lucia" in answer:
    print("Precis!")
  elif "noa" in answer:
    print("Det har du redan sagt.")
    return lucia
  else:
    print("Nja, inte det vi är ute efter.")
    return lucia

def noa_birthday():
  """
  Följdfråga om Noas födelsedag
  """
  answer = input("Det är något annat med den 13 december också, "
                 "vad? ").casefold()
  if "noa" in answer:
    print("Precis!")
  elif "lucia" in answer:
    print("Det har du redan sagt.")
    return noa_birthday
  else:
    print("Nja, inte det vi är ute efter.")
    return noa_birthday
@

\subsection{Lite aritmetik}

Vi vill även ha en fråga om aritmetik.
Här slumpar vi fram två tal mellan 0 och 1000.
Vi slumpar även om vi ska ha addition eller multiplikation.

Om användaren svarar fel, då får de ett nytt tal.
(För att åstadkomma detta returnerar vi funktionen själv för att få den igen 
som följdfråga.)
Men om användaren skriver fel, exempelvis \enquote{a} som inte kan tolkas som 
ett tal, då får användaren ett till försök på samma tal.
<<hjälpfunktioner>>=
def arithmetics():
  """
  Vi testar lite aritmetik.
  """
  a = random.randint(0, 1000)
  b = random.randint(0, 1000)
  op = random.choice("+*")

  if op == "+":
    result = a + b
  elif op == "*":
    result = a * b

  while answer := input(f"{a} {op} {b} = "):
    try:
      if int(answer) == result:
        print("Exakt!")
        return
      else:
        print("Nope, det var fel.")
        return arithmetics
    except ValueError:
      print(f"Tyvärr går inte '{answer}' att tolka som ett tal.")
@

Nu kan vi lägga till funktionen för frågan.
<<lägg till frågor i questions>>=
questions.append(arithmetics)
@


\subsection{Kuggfrågor}

Vi vill ha några kuggfrågor.
Om användaren svara fel, då får de en chans till med en annan kuggfråga.
Om man svarar fel även på den andra frågan, då avslutas programmet och man 
måste börja om från början.
<<hjälpfunktioner>>=
def wine_or_juice_wet():
  """
  Vad är blötast?
  """
  question = "Vad är blötast: ett torrt vin eller en flaska juice? "
  while answer := input(question).casefold():
    if "vin" in answer:
      print("Helt rätt! En flaska är ju torr.")
      break
    elif "juice" in answer or "båda" in answer:
      print("Nä, en flaska är torr, "
            "vin är däremot blött även om det är torrt.")
    else:
      print("Fattar inte vad du menar.")
      continue

    print("Då får du lösa en till kluring.")
    return heaviest

def heaviest():
  """
  Vad är tyngst?
  """
  question = "Vad är tyngst: ett ton bomull eller ett ton järn? "
  while answer := input(question).casefold():
    if "lika" in answer:
      print("Du har minsann huvudet på skaft!")
      break
    elif ("bomull" in answer and "järn" not in answer) \
      or ("bomull" not in answer and "järn" in answer):
      print("Nä, de är båda lika tunga, båda väger ett ton.")
    else:
      print("Fattar inte vad du menar.")
      continue

    print("Som straff får du börja om från början.")
    sys.exit(1)
@

Nu kan vi lägga till funktionen för den första frågan.
[[heaviest]] används ju bara om man missar den första frågan.
<<lägg till frågor i questions>>=
questions.append(wine_or_juice_wet)
@


\subsection{Transportera räven, hönan och säden}

Vi har en räv, en höna och en påse säd.
Vi ska transportera dem över en älv med en båt.
Vi kan inte lämna räven ensam med hönan (då äter räven upp hönan) och inte 
heller hönan med säden (då äter hönan upp säden).

Det här spelet kan pågå i flera omgångar, användaren kan flytta samma sak fram 
och sedan tillbaka igen.
På så vis behöver vi en robust konstruktion som kan fortsätta i oändlighet.

Som uppvärmning kan vi inleda med en hjälpfunktion som låter användaren välja 
ett av flera alternativ.
Detta är användbart då användaren ska välja vilken av hönan, räven och säden 
som ska med i båten.
<<hjälpfunktioner>>=
def input_choice(prompt, choices):
  """
  Skriv ut prompt och låt användaren välja ett alternativ från choices.
  """
  if not choices:
    raise ValueError(f"`choices` får inte vara tom.")

  print(prompt)
  while choice := input(f"{choices} ").casefold():
    if choice in choices:
      return choice
    else:
      print(f"Du måste välja något av alternativen.")
@

Nästa hjälpfunktion vi vill ha är att rita upp nuvarande uppsättning, vilka 
saker som är på vilken sida, vilken sida båten är på.
Sedan fråga användaren vad som ska med i båten och returnera resultatet, vad 
som är på vilken sida.
Det är det enda vi gör.
<<hjälpfunktioner>>=
def next_step(left, right, boat_on_right):
  """
  Kör ett steg i räv-höna-säd-spelet
  """
  left_to_print = left if left else "ingen"
  right_to_print = right if right else "ingen"

  if boat_on_right:
    print(f"{left_to_print} {'_'*15}\_| {right_to_print}")
    this = right
    other = left
  else:
    print(f"{left_to_print} |_/{'_'*15} {right_to_print}")
    this = left
    other = right

  answer = input_choice("Vem transporterar du? ", this|{"ingen"})

  if answer != "ingen":
    this.discard(answer)
    other.add(answer)

  return left, right, not boat_on_right
@

Nu kan vi sätta ihop spelet med hjälp av den här funktionen.
Och det är här vi kollar om räven äter hönan eller hönan äter säden.
Och även om användaren till slut lyckas vinna.
<<hjälpfunktioner>>=
def fox_hen_seed():
  """
  Räven, hönan och säden
  """
  print()
  print("Du har en räv, en höna och en påse utsäde.")
  print("Du måste transportera dem över en älv, men ")
  print("bara en åt gången får plats i båten.")
  print()

  left = set()
  right = {"räven", "hönan", "säden"}
  boat_on_right = True

  while tuple := next_step(left, right, boat_on_right):
    left, right, boat_on_right = tuple

    if boat_on_right:
      other = left
    else:
      other = right

    if "räven" in other and "hönan" in other:
      print("Räven åt hönan! Du förlorade, försök igen.")
      return fox_hen_seed
    if "hönan" in other and "säden" in other:
      print("Hönan åt säden. Du förlorade, försök igen.")
      return fox_hen_seed
    if left == {"räven", "hönan", "säden"}:
      print("Grattis du klarade det!")
      return
@

Nu lägger vi till den i listan med frågor.
<<lägg till frågor i questions>>=
questions.append(fox_hen_seed)
@

\subsection{Idéer till fler frågor}

Vi skulle kunna lägga till några frågor om olika djur, exempelvis höjd eller 
snabbhet.
Vi skulle även kunna jämföra djuren, exempelvis slumpa två djur och fråga 
vilket som är snabbast.


\section{Presenten}

När alla frågor är korrekt besvarade kan vi skriva ut vinsten, själva 
presenten!
För att man inte ska kunna läsa ut presenten direkt ur källkoden kan vi använda 
[[base64]].
\begin{pyblock}
import base64

gift = "Half-Life 3: ABCD-EFGH-IJKL-MNOP"

print(base64.b64encode(gift.encode("utf8")))
\end{pyblock}
Detta ger
\printpythontex[verbatim]

Nu kan vi använda denna sträng i själva koden.
På så vis måste den exekveras för att skriva ut den i läsbar text.
(Vi antar att ytterst få kan översätta base64 i huvudet.)
<<hjälpfunktioner>>=
def print_the_gift():
  """
  Skriv ut presenten
  """
  gift = b'SGFsZi1MaWZlIDM6IEFCQ0QtRUZHSC1JSktMLU1OT1A='

  print(f"""
God jul och grattis på födelsedagen!

Nu har du lyckats öppna presenten. Du har fått ...

{base64.b64decode(gift).decode("utf-8").center(80)}

  """)

  input("Tryck på en tangent för att avsluta ...")
@

Då kan vi bara anropa funktionen i huvudprogrammet.
<<skriv ut presenten>>=
print_the_gift()
@
\end{document}
