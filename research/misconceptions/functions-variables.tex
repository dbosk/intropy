\subsection{Functions and variables}

Functions and variables is often the first area which is taught in 
introductory programming, an area which holds many misconceptions. This 
section will be divided into several categories, which will reflect the 
different areas that students have trouble grasping.  


\subsubsection{Conceptual understanding of variables}
According to \textcite{
Kohn2017VariableEvaluation,Plass2015Variables,Doukakis2007}, 
sometimes students believe that variables can hold an entire algorithm and 
therefore see a variable as a function (or a mathematical equation). This 
will 
create problems when a student creates a variable in belief that the 
variable 
will dynamically change its value when the equation would change its value, 
or be updated
when the variable is used in the program. Another misconception that goes 
hand in hand with the assumption that a 
variable holds an equation and not a single value, is that if in the return 
statement the student returns an equation, the student believes that the 
return 
value will be that equation, not the value that the equation represents 
\parencite{Kohn2017VariableEvaluation}.

From a variation theoretic perspective, we can say several things about this:
\begin{enumerate}
  \item That variables and functions are interconnected and should be 
treated 
    simultaneously (not \enquote{one thing at a time}), to be able to 
contrast 
    them \parencite[\cf][Ch~6, pp~167--168]{NCOL}.
  \item Unlike in mathematics, every line in a piece of program (in an 
    imperative language) constitutes a new state of the program.
    We must teach this to students through a series of patterns, as 
dictated by 
    variation theory.
\end{enumerate}

A pattern that could be used to help students understand how a variable 
defined by a mathematical statement (for example (\mintinline{python}{x = a+
b})) is interpreted by Python, could be as followed:

\begin{description}
  \item [Contrast] Show the contrast between where \mintinline{python}{x} first 
    is defined by addition of constants and then by addition of variables.

\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}{python}
    def example():
        x = 1 + 2

        return x
  \end{minted}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\columnwidth}
  \begin{minted}[highlightlines={2-4}]{python}
    def example():
        a = 1
        b = 2
        x = a + b

        return x
  \end{minted}
\end{minipage}

    Now, according to variation theory, only the aspect in focus should change.
    Hence, we kept the name \mintinline{python}{example} in both code snippets 
    above.
    This implies that we must show the students how we change this function, 
    not create a new function that with a different name with the differences.
    (It would be natural to call one \mintinline{python}{example1} and the 
    other \mintinline{python}{example2}, but that should not be done at this 
    stage.)

    \item [Generalisation] In the generalisation pattern we instead let the 
      value of \mintinline{python}{x} vary, and keep the critical aspect (the 
      definition) invariant.

\begin{minipage}[t]{0.25\columnwidth}
  \begin{minted}[highlightlines={2-3}]{python}
    def example():
        a = 1 + 1
        b = 2
        x = a + b

        return x
  \end{minted}
\end{minipage}
\hfill
\begin{minipage}[t]{0.25\columnwidth}
  \begin{minted}[highlightlines={2-3}]{python}
    def example():
        a = 2
        b = 5 + a
        x = a + b

        return x
  \end{minted}
\end{minipage}
\hfill
\begin{minipage}[t]{0.25\columnwidth}
  \begin{minted}[highlightlines={2-3}]{python}
    def example():
        a = 3
        b = a
        x = a + b

        return x
  \end{minted}
\end{minipage}

    \item [Fusion] Here we will let the definition and value of x vary, and 
    also use the functionality of functions (in order to teach functions and 
    variables simultaneously). 

    \begin{lstlisting}[language=Python]
        def example1(a, b):
            x = a + b

            return x

        def example2(a, b):
            a = 1
            b = 2
            x = a + b

            return x

        def example3():
            a = 1
            b = 2
            x = a + b
            a = 2
            b = 3

            return x + a
            
    \end{lstlisting}
    
\end{description}



\subsubsection{Defining variables and functions}

But it is not only the right side of the variable definition that students 
can 
have misconceptions about. The name of the variable has been misunderstood 
as 
having power of the value which it holds 
\parencite{MisconceptionsSurvey2017,Sleeman1984}. For example, if a student 
names one variable \emph{max} and another variable \emph{min}, the student 
might think that the variables will strictly only hold the maximum value and 
the minimum value throughout the program, even though the code does not 
carry through this rule. 

We can both explain this phenomenon and propose a teaching design using 
variation theory.
Let's start with the explanation.
When teaching the students we always use proper (\ie relevant) variable 
names 
that relate to the purpose of the variable.
If we never show the students any examples where the variable name is not 
related to its purpose (bad variable names), they cannot separate the 
variable 
naming from its purpose.
This, inevitably, leads to the teaching design:
we must show the students that the variable names are independent of their 
purpose. To achieve this we propose this pattern:

\begin{description}
    \item [Contrast] We show a standard example, then we change a variable 
name from a relevant to an irrelevant one. We show that the program 
still works.
    \item [Generalisation] We can then \emph{generalise} this by showing 
that we can rename the other variables too, and even show other 
examples where the variable names are disconnected from the purpose.
    \item [Fusion] When done, we can point out that we name variables 
properly for readability 
(ease of comprehension), by \emph{contrasting} the same example with and 
without relevant variable names.
We can follow this by \emph{generalisation}, by showing a previously unseen 
example with unrelated variable names and trying to read it.
\end{description}


Other misconceptions that students have when defining variables were found 
by \textcite{GuoMarkelZhang2020},

\begin{enumerate}
    \item When using a variable students have the misconception that the 
      \enquote{pronoun} of the variable can be used later in the programme, 
      instead of the name that was used in the first definition of the 
      variable. For example, if a list has been defined as 
      \mintinline{python}{my_list}, the list is later referenced only as 
      \mintinline{python}{list}.

      From a variation theory perspective, this misconception can be 
managed through a similar pattern as described for the misconception 
of variable names' power of variable values. First by \emph{
contrasting} via examples where the name \mintinline{python}{my_list} 
is used throughout the programme and changed mid-programme 
respectively. Then, \emph{generalising} by using different variable 
names, but keeping them throughout the programme. The pattern ends 
with a fusion of the two.
    \item Defining a variable by using another variable students use 
      \mintinline{python}{x == y} instead of \mintinline{python}{x = y}, a 
      misconception supposedly originating from how the statement is read 
out 
      loud as \enquote{x equals y}.

      Here we propose the pattern where we first \emph{contrast} the two 
different statements, by printing the output of \mintinline{python}{x 
== y} and \mintinline{python}{x = y} separately. Both \mintinline{
python}{x} and \mintinline{python}{y} can be pre-defined, to avoid 
the programme throwing an error. However, in the contrast we could 
also include the example where an error is thrown, this to \emph{
contrast} even further. The \emph{generalisation} for this pattern is 
easy, and consists of several variable-definitions where other 
variables are used in the definition. The last pattern, \emph{Fusion} 
should consist of both variable-definitions, and where the variables 
are also used in comparison-statements. 
    \item Writing definitions of variables from left-to-right 
      (\mintinline{python}{a+b = c}) instead of right-to-left 
      (\mintinline{python}{c = a+b}). The same can be seen when using 
functions 
      in the definition of variables, for example instead of writing 
      \mintinline{python}{x=str(input())} the students write 
      \mintinline{python}{str(x) = input()}.

      This misconception can be seen as a misconception of what the 
functionality of the left and right side of a variable definition is. 
To \emph{contrast} this, we need to create code which will throw 
errors, since it is not possible to do function calls on the left 
side a variable definition. This can be done with examples from both 
misconceptions mentioned, where we do it the right way and the wrong 
way. We then \emph{generalise} it by writing several examples, with 
several function calls which will not throw errors. In this pattern 
it will however not be possible to \emph{fuse} the invariant and 
variant with each other, since the latter will throw an error for the 
programme. 
\end{enumerate}


Since Python is an interpreted language, the placement of the definition of 
a function is important, which differs from a compiled language. This gives 
room for a misconception for students that have learned to code in for 
example Java, where the definition of a function can be below a call of the 
function. 

XXX Add analysis \textbf{IF} we want to include this misconception. However 
it can be seen as out of the scope of our article, since we focus on novice 
programmers. But we still have students that might have been exposed to 
Java in high-school, so it might still be interesting to include?

\subsubsection{Arguments and return values of functions}

If we move on to the relationship between variables and functions we can see 
more misconceptions that students have; for example where input and output 
arguments 
come from and go to \parencite{Ragonis2005OOP}.
The first difficulty is how students treat return-values. When a function is 
supposed to return a value some students miss the return value, expecting 
the 
function to return it by default \parencite{Kurvinen2016,KumarVeerasamy2016}
. 
. Some students might also believe that a print-statement at the end of a 
function will act as a return statement \parencite{MisconceptionsSurvey2017}
. Furthermore, it has also been found that students that know that a return-
statement is needed have difficulties 
returning the right value or variable from a function
\parencite{KumarVeerasamy2016}. 
. 

These misconceptions are all connected to each other, and what they have in 
common is the trouble to return a value, the \emph{right} value, from a 
function. To help the students understand how to write a correct return-
statement for different functions we propose this pattern:


\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}


A student might also write a function which returns a value, but that value 
is 
not stored nor being used later in the program 
\parencite{AltadmriBrown2015}.


One can draw the conclusion that this misconception is the product of that 
students believe that a function has to have a return-statement to end, and 
that the programme will throw an error if a function misses a return-
statement. We propose this pattern to avoid this misconception:

\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}

It is not only the return value that is difficult to grasp for students, the 
input arguments are also a difficult concept for some students. When 
calling a 
function studies show that students have trouble using and understanding 
which 
arguments that are meant to be used in the function call 
\parencite{AltadmriBrown2015}. 

XXX Add analysis on how one can teach function arguments

\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}


\Textcite{Fleury1991} researched the 
misconceptions students have when using parameters in functions.
She found that students had constructed their own rules for the using 
of global and local variables which are connected to the use of variables in 
functions. These are the misconceptions she found, 

\begin{enumerate}
    \item when changing a local variable in a function, the variables with 
the same name is changed for the whole program

    \item if the local variable is not an argument in the function-call, 
the program will go back to where the function was called and search 
for it there

    \item if a function references to a global variable that is not a 
function argument, it will create an error in the program

    \item if a global variable is changed in the function body, the new 
value will not be reachable for the rest of the program if not returned 
by the function
\end{enumerate}

XXX Add analysis on how one can teach the difference between local and 
global variables and how they are used in functions. 

\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}

\subsubsection{Variables in mathematics vs programming}

The difference between variables in programming and variables in 
mathematics is something that some students do not grasp. If a student in a 
variable 
definition uses, on the right side of the equal symbol, a variable that is 
not 
defined, but the variable on the left side is already defined, they think 
that 
the computer will solve this as an equation \parencite{Plass2015Variables}. 
This assumption made by the students was also discovered by 
\textcite{Kohn2017VariableEvaluation} when giving the students the 
definition 
\mintinline{python}{x = x + 1}. If you look at this definition with a 
mathematical 
perspective you will see an unsolvable equation, which is also what some of 
the 
students saw. They did not see that the \mintinline{python}{x} to the left 
is the 
variable, 
and that the \mintinline{python}{x} to the right only holds a value. This 
definition is  
easier to understand for a novice programmer, according to 
\textcite{Kohn2017VariableEvaluation}, when we instead write this 
definition as 
\mintinline{python}{x += 1}. 

XXX Add analysis on how to help students understand the difference between 
variable definitions in programming and equations in mathematics

\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}


