\subsection{Functions and variables}

Functions and variables is often the first area which is taught in 
introductory programming, an area which holds many misconceptions. This 
section will be divided into several categories, which will reflect the 
different areas that students have trouble grasping.  

\subsubsection{Conceptual understanding of variables}

According to \textcite{
Kohn2017VariableEvaluation,Plass2015Variables,Doukakis2007}, 
sometimes students believe that variables can hold an entire algorithm and 
therefore see a variable as a function (or a mathematical equation).
This will create problems when a student creates a variable in belief that the 
variable will dynamically change its value when the equation would change its 
value, or be updated when the variable is used in the program.

Another misconception that goes hand in hand with the assumption that a 
variable holds an equation and not a single value, is that if in the return 
statement the student returns an equation, the student believes that the return 
value will be that equation, not the value that the equation represents 
\parencite{Kohn2017VariableEvaluation}.

From a variation theoretic perspective, we can say several things about 
this:
\begin{enumerate}
  \item That variables and functions are interconnected and should be treated 
    simultaneously (not \enquote{one thing at a time}), to be able to contrast 
    them \parencite[\cf][Ch~6, pp~167--168]{NCOL}.
  \item Unlike in mathematics, every line in a piece of program (in an 
    imperative language) constitutes a new state of the program.
    We must teach this to students through a series of patterns, as dictated by 
    variation theory.
\end{enumerate}

So, how should we teach functions and variables according to variation theory?
Let's assume that the students know variables and equations from mathematics 
and that that's the only prerequisite knowledge.

\subsubsection{Statefulness of variables}

\begin{description}
  \item [Contrast] We must introduce variation in the aspect (dimension) of 
    statefulness of variables, but keep all other aspects (dimensions) 
    invariant.

    \begin{minipage}[t]{0.45\columnwidth}
      \begin{pyblock}[varstateC1]
a = 1
b = 2
x = a + b



print(f"x = {x}")
      \end{pyblock}

      \vspace{0.5em}
      Which yields the following:
      \printpythontex[verbatim]
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.45\columnwidth}
      \begin{pyblock}[varstateC2][highlightlines={4-5}]
a = 1
b = 2
x = a + b
a = 2
b = 3

print(f"x = {x}")
      \end{pyblock}

      \vspace{0.5em}
      Which yields the following:
      \printpythontex[verbatim]
    \end{minipage}

    The contrast is the update of the variables \mintinline{python}{a} and 
    \mintinline{python}{b}, which doesn't cause any change---as would be 
    expected according to the misconception identified by
    \textcite{Kohn2017VariableEvaluation,Plass2015Variables,Doukakis2007}, that 
    sometimes students believe that variables can hold an entire algorithm and 
    therefore see a variable as a function (or a mathematical equation).

    \item [Generalisation] In the generalisation pattern we want to generalise 
      phenomenon to other examples, so that the student can observe when the 
      phenomenon occurs.
    
      \begin{minipage}[t]{0.45\columnwidth}
        \begin{pyblock}[varstateG1]
a = 3
b = 2
c = a + b
a = 1
b = 5

print(f"c = {c}")
        \end{pyblock}

        \vspace{0.5em}
        Which yields the following:
        \printpythontex[verbatim]
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.45\columnwidth}
        \begin{pyblock}[varstateG2]
name = "Ada"
greeting = "Hi"
msg = f"{greeting} {name}!"
name = "Beda"


print(msg)
        \end{pyblock}

        \vspace{0.5em}
        Which yields the following:
        \printpythontex[verbatim]
      \end{minipage}

      We see that we've varied the variable names and the types, still the same 
      effect.

      We can finish by updating the original definition after the updates.

      \begin{minipage}[t]{0.45\columnwidth}
        \begin{pyblock}[varstateG2]
name = "Ada"
greeting = "Hi"
msg = f"{greeting} {name}!"
name = "Beda"


print(msg)
        \end{pyblock}

        \vspace{0.5em}
        Which yields the following:
        \printpythontex[verbatim]
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.45\columnwidth}
        \begin{pyblock}[varstateG2][highlightlines=5]
name = "Ada"
greeting = "Hi"
msg = f"{greeting} {name}!"
name = "Beda"
msg = f"{greeting} {name}!"

print(msg)
        \end{pyblock}

        \vspace{0.5em}
        Which yields the following:
        \printpythontex[verbatim]
      \end{minipage}

      And then the first example again:

      \begin{minipage}[t]{0.45\columnwidth}
        \begin{pyblock}[varstateG1]
a = 3
b = 2
c = a + b
a = 1
b = 5

print(f"c = {c}")
        \end{pyblock}

        \vspace{0.5em}
        Which yields the following:
        \printpythontex[verbatim]
      \end{minipage}
      \hfill
      \begin{minipage}[t]{0.45\columnwidth}
        \begin{pyblock}[varstateG1][highlightlines=6]
a = 3
b = 2
c = a + b
a = 1
b = 5
c = a + b
print(f"c = {c}")
        \end{pyblock}

        \vspace{0.5em}
        Which yields the following:
        \printpythontex[verbatim]
      \end{minipage}
\end{description}

Now, this was just one aspect of the misconception that students believe that 
variables can hold an entire algorithm and therefore see a variable as a 
function (or a mathematical equation).
We also have that expected behaviour, namely through functions.

\subsubsection{Variability of functions}

The students' expectation that \(y = kx + m\) is a function 
\parencite{Kohn2017VariableEvaluation,Plass2015Variables,Doukakis2007} is 
likely due to the mathematical shorthand for \(y(x) = kx + m\).
Above we introduced a series of pattern showing that
\mintinline{python}{y = k*x + m}
is not the same as the dynamic relation in mathematics,
\(y = kx + m\) (or \(y(x) = kx + m\) to be precise).
However, we can achieve that dynamic relation in Python too, through functions.
Next, we'll go back and show a series of patterns to achieve the expected 
behaviour.

\begin{description}
  \item [Contrast] We must introduce variation in the aspect (dimension) of 
    statefulness of variables, but keep all other aspects (dimensions) 
    invariant.

    \begin{minipage}[t]{0.45\columnwidth}
      \begin{pyblock}[funcC1][highlightlines=3]
a = 1
b = 2
x = a + b
a = 2
b = 3

print(f"x = {x}")
      \end{pyblock}

      \vspace{0.5em}
      Which yields the following:
      \printpythontex[verbatim]
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.45\columnwidth}
      \begin{pyblock}[funcC2][highlightlines={1-2}]
def x(a, b):
  return a + b



print(f"x(1, 2) = {x(1, 2)}")
print(f"x(2, 3) = {x(2, 3)}")
      \end{pyblock}

      \vspace{0.5em}
      Which yields the following:
      \printpythontex[verbatim]
    \end{minipage}

  \item[Generalisation] We'd like to generalise this.

    \begin{minipage}[t]{0.45\columnwidth}
      \begin{pyblock}[funcG1]
def y(x):
  return 2*x + 5

print(f"y(1) = {y(1)}")
print(f"y(2) = {y(2)}")
      \end{pyblock}

      \vspace{0.5em}
      Which yields the following:
      \printpythontex[verbatim]
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.45\columnwidth}
      \begin{pyblock}[funcG2]
def greet(name, greeting):
  return f"{greeting} {name}!"

print(greet("Ada", "Hi"))
print(greet("Beda", "Hi"))
      \end{pyblock}

      \vspace{0.5em}
      Which yields the following:
      \printpythontex[verbatim]
    \end{minipage}

  \item[Fusion] Now we'd like to fuse this back with the statefulness of 
    variables from above.

    \begin{minipage}[t]{0.45\columnwidth}
      \begin{pyblock}[funcG1]
def y(x):
  return 2*x + 5

y1 = y(1)
y2 = y(2)
y3 = y(5)

print(f"y1 = {y1}")
print(f"y2 = {y2}")
print(f"y3 = {y3}")
      \end{pyblock}

      \vspace{0.5em}
      Which yields the following:
      \printpythontex[verbatim]
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.45\columnwidth}
      \begin{pyblock}[funcG2]
def greet(name, greeting):
  return f"{greeting} {name}!"



msg = greet("Ada", "Hi")
print(msg)

msg = greet("Beda", "Hi")
print(msg)
      \end{pyblock}

      \vspace{0.5em}
      Which yields the following:
      \printpythontex[verbatim]
    \end{minipage}

\end{description}

XXX Treat the other aspects related to functions: scope, default values, ...

Another misconception that goes hand in hand with the assumption that a 
variable holds an equation and not a single value, is that if in the return 
statement the student returns an equation, the student believes that the return 
value will be that equation, not the value that the equation represents 
\parencite{Kohn2017VariableEvaluation}.


\subsubsection{Defining variables and functions}

But it is not only the right side of the variable definition that students 
can 
have misconceptions about. The name of the variable has been misunderstood 
as 
having power of the value which it holds 
\parencite{MisconceptionsSurvey2017,Sleeman1984}. For example, if a student 
names one variable \emph{max} and another variable \emph{min}, the student 
might think that the variables will strictly only hold the maximum value 
and 
the minimum value throughout the program, even though the code does not 
carry through this rule. 

We can both explain this phenomenon and propose a teaching design using 
variation theory.
Let's start with the explanation.
When teaching the students we always use proper (\ie relevant) variable 
names 
that relate to the purpose of the variable.
If we never show the students any examples where the variable name is not 
related to its purpose (bad variable names), they cannot separate the 
variable 
naming from its purpose.
This, inevitably, leads to the teaching design:
we must show the students that the variable names are independent of their 
purpose. To achieve this we propose this pattern:

\begin{description}
    \item [Contrast] We show a standard example, then we change a variable 
name from a relevant to an irrelevant one. We show that the program 
still works.
    
    \hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def example(values):
                maximum = 0
                for value in values:
                    if value > maximum:
                        maximum = value
    
                return maximum
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={2,4-5,7}]{python}
            def example(values):
                x = 0
                for value in values:
                    if i > x:
                        x = i
    
                return x
      \end{minted}
    \end{minipage}
\newline
    
    \item [Generalisation] We can then \emph{generalise} this by showing 
that we can rename the other variables too. We can even show other 
examples where the variable names are disconnected from the purpose.

    
    \hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={}]{python}
            def example(l):
                maximum = 0
                for i in l:
                    if i > maximum:
                        maximum = i
    
                return maximum
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightcolor=light-green, highlightlines={2,7}]{
python}
             def example(values):
                maximum = 0
                for value in values:
                    if value < maximum:
                        maximum = value
    
                return maximum
      \end{minted}
    \end{minipage}
\newline
    \item [Fusion] When done, we can point out that we name variables 
properly for readability (ease of comprehension), by \emph{contrasting}
 the same example with and without relevant variable names. We can 
follow this by \emph{generalisation}, by showing a previously unseen 
example with unrelated variable names and trying to read it.
    
    \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def example(l):
                x = 0
                for i in l:
                    if i > x:
                        x = i
    
                return x
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
             def example(hi):
                y = []
                
                variable = hi.readlines()
    
                for i in variable:
                    x = i.split()
                    object = Class1(x[0], x[1])
                    y.append(object)
                    
                for i in y:
                    if y.property2 > 18:
                        print(f"Hi {y.property1}! 
                        You are an adult.")
        \end{minted}
    \end{minipage}
\hfill
    
\end{description}
\vspace{5pt}
Other misconceptions that students have when defining variables were found 
by \textcite{GuoMarkelZhang2020},

\begin{enumerate}
    \item When using a variable students have the misconception that the 
      \enquote{pronoun} of the variable can be used later in the programme, 
      instead of the name that was used in the first definition of the 
      variable. For example, if a list has been defined as 
      \mintinline{python}{my_list}, the list is later referenced only as 
      \mintinline{python}{list}.

      From a variation theory perspective, this misconception can be 
managed through a similar pattern as described for the misconception 
of variable names' power of variable values. First by \emph{
contrasting} via examples where the name \mintinline{python}{my_list}
 is used throughout the programme and changed mid-programme 
respectively. 
      
    \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def example():
                maximum = 0
                for value in my_list:
                    if value > maximum:
                        maximum = value
    
                return maximum
                
            my_list = [1, 3, 2, 5, 4]
            maximum = example()
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={3}]{python}
            def example():
                maximum = 0
                for value in list:
                    if value > maximum:
                        maximum = value
    
                return maximum

            my_list = [1, 3, 2, 5, 4]
            maximum = example()
        \end{minted}
    \end{minipage}
\hfill
     
      Then, \emph{generalising} by using different variable names, but 
keeping them throughout the programme. 
        \hfill
        \begin{minted}{python}
            def example():
                for value in my_list:
                    if value > maximum:
                        maximum = value
    
            maximum = 4
            my_list = [1, 3, 2, 5, 4]
            example()
        \end{minted}
\hfill

The pattern ends with a fusion of the two.
\hfill
        \begin{minted}{python}
            def example():
                for value in list:
                    if value > maximum:
                        maximum = value


            maximum = 4
            my_list = [1, 3, 2, 5, 4]
            example()
        \end{minted}

\hfill
    
    \item Defining a variable by using another variable students use 
      \mintinline{python}{x == y} instead of \mintinline{python}{x = y}, a 
      misconception supposedly originating from how the statement is read 
out 
      loud as \enquote{x equals y}.

      Here we propose the pattern where we first \emph{contrast} the two 
different statements, by printing the output of \mintinline{python}{
x == y} and \mintinline{python}{x = y} separately. Both \mintinline{
python}{x} and \mintinline{python}{y} can be pre-defined, to avoid 
the programme throwing an error. However, in the contrast we could 
also include the example where an error is thrown, this to \emph{
contrast} even further. 

      \hfill
     \begin{minipage}[t]{0.3\columnwidth}
        \begin{minted}{python}
            def example():
                x = 1
                y = 2
                x == y
    
                return x
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.3\columnwidth}
        \begin{minted}[highlightlines={4}]{python}
            def example():
                x = 1
                y = 2
                x = y
                
                return x
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.3\columnwidth}
        \begin{minted}[highlightlines={3}]{python}
            def example():
                y = 2
                x == y 
                # Will throw an 
                # error
                return x
        \end{minted}
    \end{minipage}
\hfill
    
      The \emph{generalisation} for this pattern is easy, and consists of 
several variable-definitions where other variables are used in the 
definition. Here again we are also including different function 
functionalities, to help students understand variables and functions 
simultaneously. 

      \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def example(y):
                x = y

    
                return x   
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={}]{python}
            def example():
                a = 3
                b = a
    
                return b
        \end{minted}
    \end{minipage}
\hfill
     
      
      The last pattern, \emph{Fusion} should consist of both variable-
definitions, and where the variables also are used in comparison-
statements. 

      \begin{lstlisting}[language=Python]

        def example1():
            XXX Not really sure of a good example for this... 
            maybe an absolut-value example?
                
    \end{lstlisting}
    \item Writing definitions of variables from left-to-right 
      (\mintinline{python}{a+b = c}) instead of right-to-left 
      (\mintinline{python}{c = a+b}). The same can be seen when using 
functions 
      in the definition of variables, for example instead of writing 
      \mintinline{python}{x=parse(input())} the students write 
      \mintinline{python}{parse(x) = input()}.

      This misconception can be seen as a misconception of what the 
functionality of the left and right side of a variable definition 
is. To \emph{contrast} this, we need to create code which will throw 
errors, since it is not possible to do function calls on the left 
side of a variable definition. This can be done with examples from 
both misconceptions mentioned, where we do it the right way and the 
wrong way, using the same examples as \textcite{GuoMarkelZhang2020}.

            \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def example():
                a = 1
                b = 2
                c = a + b  
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={4}]{python}
            def example():
                a = 1
                b = 2
                a + b = c 
                # Will throw an 
                # error  
        \end{minted}
    \end{minipage}
\hfill
\vspace{5pt}
\hfill 
        \begin{minipage}[t]{0.45\columnwidth}
            \begin{minted}[highlightlines={}]{python}
                def example():
                    x = parse(input())
            \end{minted}
        \end{minipage}
        \hfill
        \begin{minipage}[t]{0.45\columnwidth}
            \begin{minted}[highlightlines={2}]{python}
                def example():
                    parse(x) = input() 
                    # Will throw an 
                    # error
            \end{minted}
        \end{minipage}
        \hfill
      
      We then \emph{generalise} it by writing an example, with several 
function calls which will not throw errors. 

        \begin{minted}[highlightlines={}]{python}
            def example():
                number = int(input("Write a number "))
                new_number = number + 1
                string_number = str(abs(new_number))
        \end{minted}
\hfill
      
      In this pattern it will however not be possible to \emph{fuse} the 
invariant and variant with each other, since the latter will throw 
an error for the programme. XXX Or can you think of a fusion Daniel?
\end{enumerate}


Since Python is an interpreted language, the placement of the definition of 
a function is important, something that differs from a compiled language. 
This gives 
room for a misconception for students that have learned to code in for 
example Java, where the definition of a function can be below a call of the 
function. 

XXX Add analysis \textbf{IF} we want to include this misconception. However 
it can be seen as out of the scope of our article, since we focus on novice 
programmers. But we still have students that might have been exposed to 
Java in high-school, so it might still be interesting to include?

\subsubsection{Arguments and return values of functions}

If we move on to the relationship between variables and functions we can 
see 
more misconceptions that students have; for example where input and output 
arguments 
come from and go to \parencite{Ragonis2005OOP}.
The first difficulty is how students understand and treat return-values, 
where these student misconceptions have been found: 

\begin{enumerate}
    \item Missing to return the variable when a function is supposed to, 
expecting the function to return it by default \parencite{
Kurvinen2016,KumarVeerasamy2016}.

    \item Believe that a print-statement at the end of a function will act 
as a return statement \parencite{MisconceptionsSurvey2017}.

\end{enumerate}
 

These two misconceptions are connected to each other, and what they have 
in common is the trouble to return a value, the \emph{right} value, from a 
function. However, the two misconceptions can be, and according to us 
should be, treated separately. To help the students understand how to 
write a correct return-statement for different functions we propose these 
two patterns for the two misconceptions:

\begin{enumerate}
    \item To help the students understand that a function will not return 
the correct value by default, we start with \emph{contrasting} with 
the help of a function which in the first example does not return a 
value, and in the second return the value. We name the functions 
\mintinline{python}{find_maximum}, this to trigger the misconception 
since this might "trick" students into believing that the return value 
will automatically be the expected value (in this case the maximum). 

    \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def find_maximum(values):
                maximum = 0
    
                for value in values:
                    if value > maximum:
                        maximum = value 


            
            x = find_maximum([1,3,2])
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={8}]{python}
            def find_maximum(values):
                maximum = 0
    
                for value in values:
                    if value > maximum:
                        maximum = value
                        
                return maximum
            
            x = find_maximum([1,3,2])
        \end{minted}
    \end{minipage}
\hfill

    Then we \emph{generalise} by showing two different examples where we 
return the expected value. 
     \hfill
        \begin{minted}{python}
            def read_file(filename):
                file = open(filename, "r")
                lines = file.readlines()
    
                return lines
        \end{minted}

\hfill

        \begin{minted}[highlightlines={}]{python}
            def calculate_average(values):
                values_sum = sum(values)
                average = values_sum/len(values)
         
                return average
        \end{minted}
\hfill

    And the last step of the pattern, the \emph{fusion}, consists of an 
example where we use functions that return the expected value, and not.
    \hfill

        \begin{minted}{python}
        def read_file(filename):
            file = open(filename, "r")
            lines = file.readlines()

            return lines
            
        def calculate_average(values):
                values_sum = sum(values)
                average = values_sum/len(values)

        def main():
            lines = readfile("test.txt")
            values = []
            for line in lines:
                values.append(int(line[0]))
            average = calculate_average(values)
            print(average)
        \end{minted}
\hfill

    \item The latter misconception we believe originates from the 
students' misconception that what they see in the terminal is what 
happening in the programme. So when we print the value that we want to 
be returned, the programme will see it and can later use it. We start 
the pattern with \emph{contrasting} this concept, using the same 
example as above.

        \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def find_maximum(values):
                maximum = 0
                for value in values:
                    if value > maximum:
                        maximum = value
    
                print(maximum)

            x = find_maximum([1,3,2])
            print(x)
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={7}]{python}
            def find_maximum(values):
                maximum = 0
                for value in values:
                    if value > maximum:
                        maximum = value
                        
                return maximum
    
            x = find_maximum([1,3,2])
            print(x)
        \end{minted}
    \end{minipage}
\hfill

    Here the students will see the maximum in the terminal when calling 
\mintinline{python}{find_maximum}, and might therefore believe that x 
will hold the value the function printed. The \emph{generalisation} 
for this misconception will be the same as for the first 
misconception, but the \emph{fusion} will differ slightly. When we 
\emph{fuse} in this pattern, we instead vary between returning the 
correct value and only printing it.
     \hfill
        \begin{minted}{python}
        def read_file(filename):
            file = open(filename, "r")
            lines = file.readlines()

            print(lines)
            
        def calculate_appearences(lines):
            num_appearences = 0
            for line in lines:
                if line[0] == "Adam":
                    num_appearences += 1
            return num_appearences
            

        def main():
            lines = readfile("test.txt")
            appearences = calculate_appearences(lines)
            print(appearences)
        \end{minted}
\hfill
    
\end{enumerate}

A student might also write a function which returns a value, but that 
value is not stored nor being used later in the program 
\parencite{AltadmriBrown2015}.


We draw the conclusion that this misconception can be the product of 
students believing that a function has to have a return-statement to end, 
and that the programme will throw an error if a function misses a return-
statement. We propose this pattern to avoid this misconception:

\begin{description}
    \item[Contrast] To contrast this misconception, we write a function 
that is not meant to return a value, with and without a return-
statement. To contrast it even further we print the return-value 
\mintinline{python}{None}, to show the students that the two functions 
return the same value. 

      \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def example():
                print("Hello world!")

                return

            print(example())
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={4}]{python}
            def example():
                print("Hello world!")



            print(example())
        \end{minted}
    \end{minipage}
\hfill

    
    \item[Generalisation] In the generalisation of this pattern we write 
different functions which all misses a return-statement, to show the 
students that the functions still executes and ends without it. 

    \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def example(lines):
                file = open("test","w")
                for line in lines: 
                    file.write(line)
                file.close()
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={}]{python}
            def example():
                print("Menu options")
                print("A. Open file")
                print("B. Add person")
                print("C. Delete person")
        \end{minted}
    \end{minipage}
\hfill
    \item[Fusion] We know fuse the invariant and the variant in the 
earlier examples, with a programme that have functions with and 
without return-statements. 
    \hfill
        \begin{minted}{python}
        def print_menu(filename):
            print("Menu options")
            print("A. Open file")
            print("B. Add person")
            print("C. Delete person")
            
        def add_person(file):
                name = input("Name? ")
                file = open("file","a")
                file.write(name)
                file.close()
                
            return

        def main():
            file = "names.txt"
            print_menu()
            option = input()
            if option == "B":
                add_person(file)
        \end{minted}
\hfill

\end{description}

It is not only the return value that is difficult to grasp for students, 
the 
input arguments are also a difficult concept for some students. When 
calling a 
function \textcite{AltadmriBrown2015} found that students often have 
trouble passing the right parameter when invoking a function, for example 
by inserting data of wrong type in the function call. 

This misconception students have when invoking functions, shows a gap in 
the conceptual understanding of function arguments and parameters. To 
avoid this and to help students grasp the relationship between function 
arguments and parameters in function calls we propose this pattern:

\begin{description}
    \item[Contrast] First we contrast with an example of when we pass a 
parameter in the correct data type to a function, and what happens if 
we pass the wrong type. Since there are several common data types used 
in CS1, we have created examples for strings, integers and lists. 

     \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def example(num):
                print("You have "+num)

            num = input("Number:")
            example(num)
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={5}]{python}
            def example(num):
                print("You choose "+num)
                # Will throw
                # an error
            num = int(input("Number:"))
            example(num)
        \end{minted}
    \end{minipage}
\hfill

    \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            import random as r
            
            def example(num):
                random = r.randint(0,9)
                new = random + num

                return new

                
            num = int(input("Number:"))
            print(example(num))
        \end{minted}
    \end{minipage}
\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={10}]{python}
            def example(lines):
                for line in lines:
                    print(line)

            f_name = "test.txt"
            file = open(f_name,'r')
            content = file.readlines()
            example(content)
        \end{minted}
    \end{minipage}
\hfill

\hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={7}]{python}
            def example(lines):
                for line in lines:
                    print(line)

            f_name = "test.txt"
            file = open(f_name,'r')
            content = file.readline()
            example(content)
        \end{minted}
    \end{minipage}
\hfill

The last contrast will not throw an error, however it might not do what 
the students expected.. 
    
    \item[Generalisation] To generalise we write several examples where it 
is important to include the correct data type in order for the 
programme to work as expected.


    \hfill
     \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}{python}
            def example(a, b):
                c = a + b

                return c
        \end{minted}
    \end{minipage}
\hfill
 \hfill
    \begin{minipage}[t]{0.45\columnwidth}
        \begin{minted}[highlightlines={}]{python}
            def example(index, names):
                try:
                    print(names[index])
                except IndexError:
                    print("Does not exist")
        \end{minted}
    \end{minipage}
\hfill

    
    \item[Fusion] In the fusion we will go back to the last example of the 
generalisation, but instead we will show what happens when we, by 
mistake, switches the places of the parameters. This will lead to 
wrong data types for the example function and lead to an error. 
     \hfill
        \begin{minted}[highlightlines={}]{python}
            def example(index, names):
                try:
                    print(names[index])
                except IndexError:
                    print("Does not exist")

            def main():
                names = ["Eva", "Adam", "Mark"]
                index = int(input("What index do you want to print? "))
                example(names, i)
        \end{minted}
\hfill

    
\end{description}


\Textcite{Fleury1991} researched the 
misconceptions students have when using parameters in functions.
She found that students had constructed their own rules for the using 
of global and local variables which are connected to the use of variables 
in 
functions. These are the misconceptions she found, and for each 
misconception we propose a pattern: 

\begin{enumerate}
    \item when changing a local variable in a function, the variables with 
the same name is changed for the whole program

    \begin{description}
        \item[Contrast] We begin by contrasting, where we first change the 
local variable by returning the value from the example function. 
Then we show an example where students might believe that the 
local variable number will change automatically for both functions. 
    
    \hfill
     \begin{minipage}[t]{0.4\columnwidth}
        \begin{minted}{python}
            import random as r
            
            def example(num):
                rand = r.randint(0,9)
                num = rand + num

                return num

            def main():
                num = 1
                num = example(num)
                print(num)
        \end{minted}
    \end{minipage}
\hfill
 \hfill
    \begin{minipage}[t]{0.4\columnwidth}
        \begin{minted}[highlightlines={7,11}]{python}
        import random as r
        
            def example(num):
                rand = r.randint(0,9)
                num = rand + num



            def main():
                num = 1
                example(num)
                print(num)
        \end{minted}
    \end{minipage}
\hfill


    \item[Generalisation] We then generalise, where we update the local 
variable in a correct way.

    \hfill
     \begin{minipage}[t]{0.4\columnwidth}
        \begin{minted}{python}
            def example(i, values):
                print(values[i])
                i += 1

                return i

            def main():
                values = [1,2,3]
                i = 0
                while i < 3:
                    i = example(i, values)
        \end{minted}
    \end{minipage}
\hfill
 \hfill
    \begin{minipage}[t]{0.4\columnwidth}
        \begin{minted}[highlightlines={7,11}]{python}
            def example(phrase):
                phrase += input()

                return phrase

            def main():
                phrase = "Phrase: "
                phrase = example(phrase)
                print(phrase)
        \end{minted}
    \end{minipage}
\hfill
    
    \item[Fusion] Lastly, we fuse the misconception 
\end{description}



    \item if the local variable is not an argument in the function-call, 
the program will go back to where the function was called and search 
for it there

    \item if a function references to a global variable that is not a 
function argument, it will create an error in the program

    \item if a global variable is changed in the function body, the new 
value will not be reachable for the rest of the program if not returned 
by the function
\end{enumerate}


\subsubsection{Variables in mathematics vs programming}

The difference between variables in programming and variables in 
mathematics is something that some students do not grasp. If a student in a 
variable 
definition uses, on the right side of the equal symbol, a variable that is 
not 
defined, but the variable on the left side is already defined, they think 
that 
the computer will solve this as an equation \parencite{Plass2015Variables}. 
This assumption made by the students was also discovered by 
\textcite{Kohn2017VariableEvaluation} when giving the students the 
definition 
\mintinline{python}{x = x + 1}. If you look at this definition with a 
mathematical 
perspective you will see an unsolvable equation, which is also what some of 
the 
students saw. They did not see that the \mintinline{python}{x} to the left 
is the 
variable, 
and that the \mintinline{python}{x} to the right only holds a value. This 
definition is  
easier to understand for a novice programmer, according to 
\textcite{Kohn2017VariableEvaluation}, when we instead write this 
definition as 
\mintinline{python}{x += 1}. 

XXX Add analysis on how to help students understand the difference between 
variable definitions in programming and equations in mathematics

\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}

\endinput

\subsection{Arguments to functions}

We start with the following example.
\begin{pyblock}[greet]
def greet(name, place):
    print(f"Hello {name}, so you're from {place}?")

def main():
    name = "Ada"
    place = "Computer Town"
    greet(name, place)

main()
\end{pyblock}
The output of running the code will be:
\stdoutpythontex[verbatim]

\subsection{Scope of identifiers}

\begin{pyblock}[greet-scope][highlightlines={5-7}]
def greet(name, place):
    print(f"Hello {name}, so you're from {place}?")

def main():
    the_name = "Ada"
    the_place = "Computer Town"
    greet(the_name, the_place)

main()
\end{pyblock}

\begin{pyblock}[greet-scope-more][highlightlines={5}]
def greet(name, place)
    print(f"Hello {name}, so you're from {place}?")

def main():
    greet("Ada", "Computer Town")

main()
\end{pyblock}

\subsection{Order of arguments}

\begin{pyblock}[greet-order][highlightlines={1,7}]
def greet(name, place):
    print(f"Hello {name}, so you're from {place}?")

def main():
    name = "Ada"
    place = "Computer Town"
    greet(place, name)

main()
\end{pyblock}



