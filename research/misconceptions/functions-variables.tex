\subsection{Functions and variables}

Functions and variables is often the first area which is taught in 
introductory programming, an area which holds many misconceptions. This 
section will be divided into several categories, which will reflect the 
different areas that students have trouble grasping.  


\subsubsection{Conceptual understanding of variables}
According to 
\textcite{Kohn2017VariableEvaluation,Plass2015Variables,Doukakis2007}, 
sometimes students believe that variables can hold an entire algorithm and 
therefore see a variable as a function (or a mathematical equation). This will 
create problems when a student creates a variable in belief that the variable 
will dynamically change its value when the equation would change its value, or 
be updated
when the variable is used in the program. Another misconception that goes 
hand in hand with the assumption that a 
variable holds an equation and not a single value, is that if in the return 
statement the student returns an equation, the student believes that the 
return 
value will be that equation, not the value that the equation represents 
\parencite{Kohn2017VariableEvaluation}.

From a variation theoretic perspective, we can say several things about this:
\begin{enumerate}
  \item That variables and functions are interconnected and should be 
treated 
    simultaneously (not \enquote{one thing at a time}), to be able to 
contrast 
    them \parencite[\cf][Ch~6, pp~167--168]{NCOL}.
  \item Unlike in mathematics, every line in a piece of program (in an 
    imperative language) constitutes a new state of the program.
    We must teach this to students through a series of patterns, as 
dictated by 
    variation theory.
\end{enumerate}

A pattern that could be used to help students understand how a variable defined 
by a mathematical statement (for example (\mintinline{python}{x = a + b})) is 
interpreted by Python, could be as followed:

\begin{description}
    \item [Contrast] Show the contrast between where x first is defined by 
addition of variables, then by addition of variables where the value of 
the variables is changed after the definition of x. The contrast is 
shown by printing all these variations, where the value of x is 
invariant, but the value of the variables is the variant. 
    \begin{lstlisting}[language=Python]

        def example1():
            a = 1
            b = 2
            x = a + b

            return x

        def example2():
            a = 1
            b = 2
            x = a + b
            a = 2
            b = 3

            return x
            
    \end{lstlisting}

    \item [Generalisation] In the generalisation pattern we instead let the 
value of x vary, and keep the critical aspect (the definition) 
invariant. 
    \begin{lstlisting}[language=Python]

        def example1():
            a = 3
            b = 2
            x = a + b

            return x

        def example2():
            a = 2
            b = 5
            x = a + b

            return x
            
    \end{lstlisting}

    \item [Fusion] Here we will let the definition and value of x vary, and 
also use the functionality of functions (in order to teach functions 
and variables simultaneously). 

    \begin{lstlisting}[language=Python]
        def example1(a, b):
            x = a + b

            return x

        def example2(a, b):
            a = 1
            b = 2
            x = a + b
            a = 2
            b = 3

            return x

        def example3():
            a = 1
            b = 2
            x = a + b
            a = 2
            b = 3
            x = a + b

            return x
            
    \end{lstlisting}
    
\end{description}



\subsubsection{Defining variables and functions}

But it is not only the right side of the variable definition that students 
can 
have misconceptions about. The name of the variable has been misunderstood 
as 
having power of the value which it holds 
\parencite{MisconceptionsSurvey2017,Sleeman1984}. For example, if a student 
names one variable \emph{max} and another variable \emph{min}, the student 
might think that the variables will strictly only hold the maximum value and 
the minimum value throughout the program, even though the code does not 
carry through this rule. 

We can both explain this phenomenon and propose a teaching design using 
variation theory.
Let's start with the explanation.
When teaching the students we always use proper (\ie relevant) variable 
names 
that relate to the purpose of the variable.
If we never show the students any examples where the variable name is not 
related to its purpose (bad variable names), they cannot separate the 
variable 
naming from its purpose.
This, inevitably, leads to the teaching design:
we must show the students that the variable names are independent of their 
purpose. To achieve this we propose this pattern:

\begin{description}
    \item [Contrast] We show a standard example, then we change a variable 
name from a relevant to an irrelevant one. We show that the program 
still works.
    \begin{lstlisting}[language=Python]

        def example1(values):
            maximum = 0
            for value in values:
                if value > maximum:
                    maximum = value

            return maximum

        def example2(values):
            x = 0

            for value in values:
                if i > x:
                    x = i

            return x
            
    \end{lstlisting}

    
    \item [Generalisation] We can then \emph{generalise} this by showing 
that we can rename the other variables too. We can even show other 
examples where the variable names are disconnected from the purpose.

    \begin{lstlisting}[language=Python]

        def example1(l):
            maximum = 0
            for i in l:
                if i > maximum:
                    maximum = i

            return maximum

        def example2(values):
            x = 0

            for value in values:
                if value < x:
                    x = value

            return x
            
    \end{lstlisting}
    
    \item [Fusion] When done, we can point out that we name variables 
properly for readability (ease of comprehension), by \emph{contrasting} 
the same example with and without relevant variable names. We can 
follow this by \emph{generalisation}, by showing a previously unseen 
example with unrelated variable names and trying to read it.

    \begin{lstlisting}[language=Python]

        def example1(l):
            x = 0

            for i in l:
                if i > x:
                    x = i

            return x

        def example2(hi):
            y = []
            
            variable = hi.readlines()

            for i in variable:
                x = i.split()
                object = Class1(x[0], x[1])
                y.append(object)
                
            for i in y:
                if y.property2 > 18:
                    print(f"Hi {y.property1}! You are an adult.")
            
    \end{lstlisting}

    
\end{description}


Other misconceptions that students have when defining variables were found 
by \textcite{GuoMarkelZhang2020},

\begin{enumerate}
    \item When using a variable students have the misconception that the 
      \enquote{pronoun} of the variable can be used later in the programme, 
      instead of the name that was used in the first definition of the 
      variable. For example, if a list has been defined as 
      \mintinline{python}{my_list}, the list is later referenced only as 
      \mintinline{python}{list}.

      From a variation theory perspective, this misconception can be 
managed through a similar pattern as described for the misconception 
of variable names' power of variable values. First by \emph{
contrasting} via examples where the name \mintinline{python}{my_list} 
is used throughout the programme and changed mid-programme 
respectively. 

       \begin{lstlisting}[language=Python]

        def example1():
            maximum = 0
            for value in my_list:
                if value > maximum:
                    maximum = value

            return maximum

        def example2():
            maximum = 0

            for value in list:
                if value > maximum:
                    maximum = value

            return maximum


        my_list = [1, 3, 2, 5, 4]
        maximum = example1()
        maximum = example2()
            
    \end{lstlisting}
      
      Then, \emph{generalising} by using different variable names, but 
keeping them throughout the programme. 

      \begin{lstlisting}[language=Python]

        def example1():
            for value in my_list:
                if value > maximum:
                    maximum = value


        maximum = 4
        my_list = [1, 3, 2, 5, 4]
        example1()
            
    \end{lstlisting}
      
      The pattern ends with a fusion of the two.

      \begin{lstlisting}[language=Python]

        def example1():
            for value in list:
                if value > maximum:
                    maximum = value


        maximum = 4
        my_list = [1, 3, 2, 5, 4]
        example1()
            
    \end{lstlisting}
    \item Defining a variable by using another variable students use 
      \mintinline{python}{x == y} instead of \mintinline{python}{x = y}, a 
      misconception supposedly originating from how the statement is read 
out 
      loud as \enquote{x equals y}.

      Here we propose the pattern where we first \emph{contrast} the two 
different statements, by printing the output of \mintinline{python}{x 
== y} and \mintinline{python}{x = y} separately. Both \mintinline{
python}{x} and \mintinline{python}{y} can be pre-defined, to avoid 
the programme throwing an error. However, in the contrast we could 
also include the example where an error is thrown, this to \emph{
contrast} even further. 
      
      \begin{lstlisting}[language=Python]

        def example1():
            x = 1
            y = 2
            x == y

            return x

        def example2():
            x = 1
            y = 2
            x = y
            
            return x

        def example3():
            y = 2
            x == y # Will throw an error

            return x

    \end{lstlisting}
    
      The \emph{generalisation} for this pattern is easy, and consists of 
several variable-definitions where other variables are used in the 
definition. 

      \begin{lstlisting}[language=Python]

        def example1(y):
            x = y

            return x   
            

        def example2():
            a = 3
            b = a

            return b
            
    \end{lstlisting}
      
      The last pattern, \emph{Fusion} should consist of both variable-
definitions, and where the variables also are used in comparison-
statements. 

      \begin{lstlisting}[language=Python]

        def example1():
            XXX Not really sure of a good example for this... 
            maybe an absolut-value example?
                
    \end{lstlisting}
    \item Writing definitions of variables from left-to-right 
      (\mintinline{python}{a+b = c}) instead of right-to-left 
      (\mintinline{python}{c = a+b}). The same can be seen when using 
functions 
      in the definition of variables, for example instead of writing 
      \mintinline{python}{x=parse(input())} the students write 
      \mintinline{python}{parse(x) = input()}.

      This misconception can be seen as a misconception of what the 
functionality of the left and right side of a variable definition is. 
To \emph{contrast} this, we need to create code which will throw 
errors, since it is not possible to do function calls on the left 
side of a variable definition. This can be done with examples from 
both misconceptions mentioned, where we do it the right way and the 
wrong way, using the same examples as \textcite{GuoMarkelZhang2020}.

      \begin{lstlisting}[language=Python]

        def example1():
            a = 1
            b = 2
            c = a + b
            a + b = c # Will throw an error

        def example2():
            x = parse(input())
            parse(x) = input() # Will throw an error
            
    \end{lstlisting}
      
      We then \emph{generalise} it by writing several examples, with 
several function calls which will not throw errors. 

      \begin{lstlisting}[language=Python]

        def example1():
            number = int(input("Write a number "))

            new_number = number + 1

            string_number = str(abs(new_number))
            
    \end{lstlisting}
      
      In this pattern it will however not be possible to \emph{fuse} the 
invariant and variant with each other, since the latter will throw an 
error for the programme. XXX Or can you think of a fusion Daniel?
\end{enumerate}


Since Python is an interpreted language, the placement of the definition of 
a function is important, something that differs from a compiled language. 
This gives 
room for a misconception for students that have learned to code in for 
example Java, where the definition of a function can be below a call of the 
function. 

XXX Add analysis \textbf{IF} we want to include this misconception. However 
it can be seen as out of the scope of our article, since we focus on novice 
programmers. But we still have students that might have been exposed to 
Java in high-school, so it might still be interesting to include?

\subsubsection{Arguments and return values of functions}

If we move on to the relationship between variables and functions we can see 
more misconceptions that students have; for example where input and output 
arguments 
come from and go to \parencite{Ragonis2005OOP}.
The first difficulty is how students understand and treat return-values, 
where these student misconceptions have been found: 

\begin{enumerate}
    \item Missing to return the variable when a function is supposed to, 
expecting the function to return it by default \parencite{
Kurvinen2016,KumarVeerasamy2016}.

    \item Believe that a print-statement at the end of a function will act 
as a return statement \parencite{MisconceptionsSurvey2017}.

\end{enumerate}
 

These two misconceptions are connected to each other, and what they have in 
common is the trouble to return a value, the \emph{right} value, from a 
function. However, the two misconceptions can be, and according to us 
should be, treated separately. To help the students understand how to write 
a correct return-statement for different functions we propose these two 
patterns for the two misconceptions:

\begin{enumerate}
    \item To help the students understand that a function will not return 
the correct value by default, we start with \emph{contrasting} with the 
help of a function which in the first example does not return a value, 
and in the second return the value. We name the functions \mintinline{
python}{find_maximum}, this to trigger the misconception since this 
might "trick" students into believing that the return value will 
automatically be the expected value (in this case the maximum). 
    
     \begin{lstlisting}[language=Python]
        def find_maximum(list_of_values):
            maximum = 0

            for value in list_of_values:
                if value > maximum:
                    maximum = value
            
        def find_maximum2(list_of_values):
            maximum = 0

            for value in list_of_values:
                if value > maximum:
                    maximum = value
                    
            return maximum

        x = find_maximum([1,3,2,5])
        y = find_maximum2([1,3,2,5])
    \end{lstlisting}

    Then we \emph{generalise} by showing two different examples where we 
return the expected value. 

    \begin{lstlisting}[language=Python]
        def read_file(filename):
            file = open(filename, "r")
            lines = file.readlines()

            return lines
            
        def calculate_average(values):
            values_sum = sum(values)
            average = values_sum/len(values)
     
            return average
    \end{lstlisting}

    And the last step of the pattern, the \emph{fusion}, consists of an 
example where we use functions that return the expected value, and not.

    \begin{lstlisting}[language=Python]
        def read_file(filename):
            file = open(filename, "r")
            lines = file.readlines()

            return lines
            
        def calculate_average(values):
            values_sum = sum(values)
            average = values_sum/len(values)

        def main():
            lines = readfile("test.txt")
            values = []
            for line in lines:
                values.append(int(line[0]))
            average = calculate_average(values)
            print(average)
    \end{lstlisting}

    \item The latter misconception we believe originates from the students' 
misconception that what they see in the terminal is what happening in 
the programme. So when we print the value that we want to be returned, 
the programme will see it and can later use it. We start the pattern 
with \emph{contrasting} this concept, using the same example as above.

     \begin{lstlisting}[language=Python]
        def find_maximum(list_of_values):
            maximum = 0

            for value in list_of_values:
                if value > maximum:
                    maximum = value

            print(maximum)
            
        def find_maximum2(list_of_values):
            maximum = 0

            for value in list_of_values:
                if value > maximum:
                    maximum = value
                    
            return maximum

        x = find_maximum([1,3,2,5])
        y = find_maximum2([1,3,2,5])
    \end{lstlisting}

    Here the students will see the maximum in the terminal when calling 
\mintinline{python}{find_maximum}, and might therefore believe that x 
will hold the value the function printed. The \emph{generalisation} for 
this misconception will be the same as for the first misconception, but 
the \emph{fusion} will differ slightly. When we \emph{fuse} in this 
pattern, we instead vary between returning the correct value and only 
printing it.

     \begin{lstlisting}[language=Python]
        def read_file(filename):
            file = open(filename, "r")
            lines = file.readlines()

            print(lines)
            
        def calculate_appearences(lines):
            num_appearences = 0
            for line in lines:
                if line[0] == "Adam":
                    num_appearences += 1
            return num_appearences
            

        def main():
            lines = readfile("test.txt")
            appearences = calculate_appearences(lines)
            print(appearences)
    \end{lstlisting}
    
\end{enumerate}

A student might also write a function which returns a value, but that value 
is not stored nor being used later in the program 
\parencite{AltadmriBrown2015}.


One can draw the conclusion that this misconception is the product of that 
students believe that a function has to have a return-statement to end, and 
that the programme will throw an error if a function misses a return-
statement. We propose this pattern to avoid this misconception:

\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}

It is not only the return value that is difficult to grasp for students, the 
input arguments are also a difficult concept for some students. When 
calling a 
function studies show that students have trouble using and understanding 
which 
arguments that are meant to be used in the function call 
\parencite{AltadmriBrown2015}. 

XXX Add analysis on how one can teach function arguments

\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}


\Textcite{Fleury1991} researched the 
misconceptions students have when using parameters in functions.
She found that students had constructed their own rules for the using 
of global and local variables which are connected to the use of variables in 
functions. These are the misconceptions she found, 

\begin{enumerate}
    \item when changing a local variable in a function, the variables with 
the same name is changed for the whole program

    \item if the local variable is not an argument in the function-call, 
the program will go back to where the function was called and search 
for it there

    \item if a function references to a global variable that is not a 
function argument, it will create an error in the program

    \item if a global variable is changed in the function body, the new 
value will not be reachable for the rest of the program if not returned 
by the function
\end{enumerate}

XXX Add analysis on how one can teach the difference between local and 
global variables and how they are used in functions. 

\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}

\subsubsection{Variables in mathematics vs programming}

The difference between variables in programming and variables in 
mathematics is something that some students do not grasp. If a student in a 
variable 
definition uses, on the right side of the equal symbol, a variable that is 
not 
defined, but the variable on the left side is already defined, they think 
that 
the computer will solve this as an equation \parencite{Plass2015Variables}. 
This assumption made by the students was also discovered by 
\textcite{Kohn2017VariableEvaluation} when giving the students the 
definition 
\mintinline{python}{x = x + 1}. If you look at this definition with a 
mathematical 
perspective you will see an unsolvable equation, which is also what some of 
the 
students saw. They did not see that the \mintinline{python}{x} to the left 
is the 
variable, 
and that the \mintinline{python}{x} to the right only holds a value. This 
definition is  
easier to understand for a novice programmer, according to 
\textcite{Kohn2017VariableEvaluation}, when we instead write this 
definition as 
\mintinline{python}{x += 1}. 

XXX Add analysis on how to help students understand the difference between 
variable definitions in programming and equations in mathematics

\begin{description}
    \item[Contrast]
    \item[Generalisation]
    \item[Fusion]
\end{description}




